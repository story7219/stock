#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ÏôÑÏ†Ñ ÏûêÎèôÌôî Ìà¨Ïûê Î∂ÑÏÑù ÎßàÏä§ÌÑ∞ ÏãúÏä§ÌÖú
ÏÇ¨Ïö©Ïûê ÌôòÍ≤Ω(RAM 16GB, i5-4460)Ïóê ÏµúÏ†ÅÌôîÎêú Î¨¥Ïù∏ Ïö¥ÏòÅ ÏãúÏä§ÌÖú
"""

import os
import sys
import time
import json
import logging
import schedule
import asyncio
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
import warnings

# Í≤ΩÍ≥† Î©îÏãúÏßÄ ÏñµÏ†ú
warnings.filterwarnings('ignore')

# ÌîÑÎ°úÏ†ùÌä∏ Í≤ΩÎ°ú ÏÑ§Ï†ï
project_root = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, project_root)
sys.path.insert(0, os.path.join(project_root, 'src'))

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('automated_system.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class AutomationConfig:
    """ÏûêÎèôÌôî ÏÑ§Ï†ï"""
    daily_analysis_time: str = "09:00"  # Îß§Ïùº Ïò§Ï†Ñ 9Ïãú
    weekly_deep_analysis: str = "MON"   # Îß§Ï£º ÏõîÏöîÏùº
    max_concurrent_tasks: int = 2       # ÎèôÏãú Ïã§Ìñâ ÏûëÏóÖ Ïàò
    emergency_stop_cpu: float = 90.0    # CPU 90% Ï¥àÍ≥ºÏãú Ï§ëÎã®
    emergency_stop_memory: float = 85.0  # Î©îÎ™®Î¶¨ 85% Ï¥àÍ≥ºÏãú Ï§ëÎã®
    auto_backup: bool = True            # ÏûêÎèô Î∞±ÏóÖ
    notification_enabled: bool = True   # ÏïåÎ¶º ÌôúÏÑ±Ìôî

class AutomatedMasterSystem:
    """ÏôÑÏ†Ñ ÏûêÎèôÌôî ÎßàÏä§ÌÑ∞ ÏãúÏä§ÌÖú"""
    
    def __init__(self, config: AutomationConfig = None):
        self.config = config or AutomationConfig()
        self.is_running = False
        self.active_tasks = set()
        self.last_analysis_time = None
        self.analysis_results = {}
        
        # ÌïµÏã¨ Î™®Îìà Î°úÎìú
        self._load_core_modules()
        
        # ÏãúÏä§ÌÖú Î™®ÎãàÌÑ∞ Ï¥àÍ∏∞Ìôî
        self._init_system_monitor()
        
        logger.info("üöÄ ÏôÑÏ†Ñ ÏûêÎèôÌôî ÎßàÏä§ÌÑ∞ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")

    def _load_core_modules(self):
        """ÌïµÏã¨ Î™®ÎìàÎì§ÏùÑ Î°úÎìúÌï©ÎãàÎã§"""
        try:
            # Í∏∞Ï°¥ ÏãúÏä§ÌÖú Ïª¥Ìè¨ÎÑåÌä∏Îì§ import
            from src.system_monitor import SystemMonitor
            from src.ml_engine import LightweightMLEngine
            from src.scheduler import SmartScheduler
            
            # Î©îÏù∏ Î∂ÑÏÑù ÏãúÏä§ÌÖúÎì§
            from run_analysis import LightweightInvestmentAnalyzer
            from data_collector import MultiSourceDataCollector
            from investment_strategies import InvestmentStrategies
            from ai_analyzer import AIAnalyzer
            from technical_analysis import TechnicalAnalysis
            
            self.system_monitor = SystemMonitor()
            self.ml_engine = LightweightMLEngine()
            self.scheduler = SmartScheduler()
            self.investment_analyzer = LightweightInvestmentAnalyzer()
            self.data_collector = MultiSourceDataCollector()
            self.strategies = InvestmentStrategies()
            self.ai_analyzer = AIAnalyzer()
            self.technical_analyzer = TechnicalAnalysis()
            
            logger.info("‚úÖ Î™®Îì† ÌïµÏã¨ Î™®Îìà Î°úÎìú ÏôÑÎ£å")
            
        except ImportError as e:
            logger.error(f"‚ùå Î™®Îìà Î°úÎìú Ïã§Ìå®: {e}")
            # ÏµúÏÜå Í∏∞Îä•ÎßåÏúºÎ°úÎèÑ ÎèôÏûëÌïòÎèÑÎ°ù ÎåÄÏ≤¥ Î™®Îìà ÏÉùÏÑ±
            self._create_fallback_modules()

    def _create_fallback_modules(self):
        """Î™®Îìà Î°úÎìú Ïã§Ìå®Ïãú ÏµúÏÜå Í∏∞Îä• ÎåÄÏ≤¥ Î™®Îìà ÏÉùÏÑ±"""
        logger.warning("‚ö†Ô∏è ÎåÄÏ≤¥ Î™®ÎìàÎ°ú ÏãúÏä§ÌÖú Íµ¨ÏÑ±")
        
        class FallbackAnalyzer:
            def analyze_stocks(self, symbols):
                return {"status": "fallback", "symbols": symbols}
        
        self.investment_analyzer = FallbackAnalyzer()

    def _init_system_monitor(self):
        """ÏãúÏä§ÌÖú Î™®ÎãàÌÑ∞ÎßÅ Ï¥àÍ∏∞Ìôî"""
        try:
            import psutil
            
            # ÏãúÏä§ÌÖú ÏÉÅÌÉú ÌôïÏù∏
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            logger.info(f"üíª ÏãúÏä§ÌÖú ÏÉÅÌÉú - CPU: {cpu_percent}%, RAM: {memory.percent}%, Disk: {disk.percent}%")
            
            if cpu_percent > 80 or memory.percent > 75:
                logger.warning("‚ö†Ô∏è ÏãúÏä§ÌÖú Î¶¨ÏÜåÏä§ Î∂ÄÏ°± - Î≥¥ÏàòÏ†Å Î™®ÎìúÎ°ú Ï†ÑÌôò")
                self.config.max_concurrent_tasks = 1
                
        except ImportError:
            logger.warning("‚ö†Ô∏è psutil ÏóÜÏùå - ÏãúÏä§ÌÖú Î™®ÎãàÌÑ∞ÎßÅ ÎπÑÌôúÏÑ±Ìôî")

    def start_automation(self):
        """ÏûêÎèôÌôî ÏãúÏä§ÌÖú ÏãúÏûë"""
        logger.info("üéØ ÏôÑÏ†Ñ ÏûêÎèôÌôî ÏãúÏä§ÌÖú ÏãúÏûë")
        self.is_running = True
        
        # Ïä§ÏºÄÏ§Ñ ÏÑ§Ï†ï
        self._setup_schedules()
        
        # Î∞±Í∑∏ÎùºÏö¥Îìú Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
        monitor_thread = threading.Thread(target=self._background_monitor, daemon=True)
        monitor_thread.start()
        
        # Î©îÏù∏ Ïä§ÏºÄÏ§ÑÎü¨ Ïã§Ìñâ
        try:
            while self.is_running:
                schedule.run_pending()
                time.sleep(60)  # 1Î∂ÑÎßàÎã§ Ï≤¥ÌÅ¨
                
        except KeyboardInterrupt:
            logger.info("üõë ÏÇ¨Ïö©Ïûê Ï§ëÎã® ÏöîÏ≤≠")
            self.stop_automation()

    def _setup_schedules(self):
        """ÏûêÎèô Ïã§Ìñâ Ïä§ÏºÄÏ§Ñ ÏÑ§Ï†ï"""
        # Îß§Ïùº Ïò§Ï†Ñ 9Ïãú Í∏∞Î≥∏ Î∂ÑÏÑù
        schedule.every().day.at(self.config.daily_analysis_time).do(
            self._run_daily_analysis
        )
        
        # Îß§Ï£º ÏõîÏöîÏùº Ïã¨Ï∏µ Î∂ÑÏÑù
        schedule.every().monday.at("10:00").do(
            self._run_weekly_deep_analysis
        )
        
        # Îß§ÏãúÍ∞Ñ ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï≤¥ÌÅ¨
        schedule.every().hour.do(
            self._hourly_system_check
        )
        
        # Îß§ 30Î∂Ñ Í∞ÑÎã® Î™®ÎãàÌÑ∞ÎßÅ
        schedule.every(30).minutes.do(
            self._quick_monitoring
        )
        
        logger.info("üìÖ ÏûêÎèô Ïã§Ìñâ Ïä§ÏºÄÏ§Ñ ÏÑ§Ï†ï ÏôÑÎ£å")

    def _run_daily_analysis(self):
        """Îß§Ïùº ÏûêÎèô Î∂ÑÏÑù Ïã§Ìñâ"""
        if not self._check_system_resources():
            logger.warning("‚ö†Ô∏è ÏãúÏä§ÌÖú Î¶¨ÏÜåÏä§ Î∂ÄÏ°±ÏúºÎ°ú Î∂ÑÏÑù Ïó∞Í∏∞")
            return
            
        logger.info("üìä ÏùºÏùº ÏûêÎèô Î∂ÑÏÑù ÏãúÏûë")
        
        try:
            # 1. ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            market_data = self._collect_market_data()
            
            # 2. Í∏∞Ïà†Ï†Å Î∂ÑÏÑù
            technical_results = self._perform_technical_analysis(market_data)
            
            # 3. AI Î∂ÑÏÑù
            ai_results = self._perform_ai_analysis(market_data)
            
            # 4. Ï¢ÖÌï© Î∂ÑÏÑù Î∞è Top5 ÏÑ†Ï†ï
            final_results = self._generate_final_recommendations(
                technical_results, ai_results
            )
            
            # 5. Í≤∞Í≥º Ï†ÄÏû• Î∞è ÏïåÎ¶º
            self._save_and_notify_results(final_results)
            
            self.last_analysis_time = datetime.now()
            logger.info("‚úÖ ÏùºÏùº Î∂ÑÏÑù ÏôÑÎ£å")
            
        except Exception as e:
            logger.error(f"‚ùå ÏùºÏùº Î∂ÑÏÑù Ïã§Ìå®: {e}")

    def _run_weekly_deep_analysis(self):
        """Ï£ºÍ∞Ñ Ïã¨Ï∏µ Î∂ÑÏÑù"""
        logger.info("üîç Ï£ºÍ∞Ñ Ïã¨Ï∏µ Î∂ÑÏÑù ÏãúÏûë")
        
        try:
            # Îçî ÎßéÏùÄ Ï¢ÖÎ™©Í≥º Î≥µÏû°Ìïú Î∂ÑÏÑù
            symbols = self._get_extended_symbol_list()
            
            # Ïã¨Ï∏µ Î∂ÑÏÑù Ïã§Ìñâ
            deep_results = self._perform_deep_analysis(symbols)
            
            # Î∞±ÌÖåÏä§ÌåÖ
            backtest_results = self._run_backtest(deep_results)
            
            # Ï†ÑÎûµ ÏµúÏ†ÅÌôî
            optimized_strategies = self._optimize_strategies(backtest_results)
            
            # Ï£ºÍ∞Ñ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
            self._generate_weekly_report(deep_results, optimized_strategies)
            
            logger.info("‚úÖ Ï£ºÍ∞Ñ Ïã¨Ï∏µ Î∂ÑÏÑù ÏôÑÎ£å")
            
        except Exception as e:
            logger.error(f"‚ùå Ï£ºÍ∞Ñ Î∂ÑÏÑù Ïã§Ìå®: {e}")

    def _collect_market_data(self) -> Dict[str, Any]:
        """ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÏàòÏßë"""
        try:
            # Ï£ºÏöî ÏßÄÏàòÎì§
            indices = ['^GSPC', '^IXIC', '^DJI', '^KS11', '^KQ11']
            
            # Ï£ºÏöî Ï¢ÖÎ™©Îì§ (Î©îÎ™®Î¶¨ Ï†àÏïΩÏùÑ ÏúÑÌï¥ Ï†úÌïú)
            stocks = [
                'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA',  # ÎØ∏Íµ≠ Ï£ºÏöî Ï¢ÖÎ™©
                'NVDA', 'META', 'NFLX', 'CRM', 'ADBE',   # Í∏∞Ïà†Ï£º
                '005930.KS', '000660.KS', '035420.KS'    # ÌïúÍµ≠ Ï£ºÏöî Ï¢ÖÎ™©
            ]
            
            market_data = {
                'indices': self.data_collector.get_multiple_stocks(indices),
                'stocks': self.data_collector.get_multiple_stocks(stocks),
                'timestamp': datetime.now().isoformat()
            }
            
            return market_data
            
        except Exception as e:
            logger.error(f"ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®: {e}")
            return {}

    def _perform_technical_analysis(self, market_data: Dict) -> Dict:
        """Í∏∞Ïà†Ï†Å Î∂ÑÏÑù ÏàòÌñâ"""
        try:
            technical_results = {}
            
            for symbol, data in market_data.get('stocks', {}).items():
                if data is not None and not data.empty:
                    # Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞
                    technical_results[symbol] = {
                        'rsi': self.technical_analyzer.calculate_rsi(data),
                        'macd': self.technical_analyzer.calculate_macd(data),
                        'bollinger': self.technical_analyzer.calculate_bollinger_bands(data),
                        'moving_averages': self.technical_analyzer.calculate_moving_averages(data),
                        'trend_score': self.technical_analyzer.calculate_trend_score(data)
                    }
            
            return technical_results
            
        except Exception as e:
            logger.error(f"Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ïã§Ìå®: {e}")
            return {}

    def _perform_ai_analysis(self, market_data: Dict) -> Dict:
        """AI Î∂ÑÏÑù ÏàòÌñâ"""
        try:
            ai_results = {}
            
            # Gemini AI Î∂ÑÏÑù (ÏãúÏä§ÌÖú Î¶¨ÏÜåÏä§ Í≥†Î†§)
            if hasattr(self, 'ai_analyzer'):
                ai_results = self.ai_analyzer.analyze_market_sentiment(market_data)
            
            # ML ÏòàÏ∏° (Í≤ΩÎüâÌôî Î≤ÑÏ†Ñ)
            if hasattr(self, 'ml_engine'):
                ml_predictions = self.ml_engine.predict_trends(market_data)
                ai_results['ml_predictions'] = ml_predictions
            
            return ai_results
            
        except Exception as e:
            logger.error(f"AI Î∂ÑÏÑù Ïã§Ìå®: {e}")
            return {}

    def _generate_final_recommendations(self, technical_results: Dict, ai_results: Dict) -> Dict:
        """ÏµúÏ¢Ö Ï∂îÏ≤ú Ï¢ÖÎ™© ÏÉùÏÑ±"""
        try:
            # Ìà¨Ïûê Ï†ÑÎûµÎ≥Ñ Ï†êÏàò Í≥ÑÏÇ∞
            strategy_scores = {}
            
            for symbol in technical_results.keys():
                # ÏõåÎü∞ Î≤ÑÌïè Ï†ÑÎûµ Ï†êÏàò
                buffett_score = self.strategies.calculate_buffett_score(symbol, technical_results[symbol])
                
                # ÌîºÌÑ∞ Î¶∞Ïπò Ï†ÑÎûµ Ï†êÏàò
                lynch_score = self.strategies.calculate_lynch_score(symbol, technical_results[symbol])
                
                # Î≤§Ï†ÄÎØº Í∑∏Î†àÏù¥ÏóÑ Ï†ÑÎûµ Ï†êÏàò
                graham_score = self.strategies.calculate_graham_score(symbol, technical_results[symbol])
                
                # AI Î≥¥ÎÑàÏä§ Ï†êÏàò
                ai_bonus = ai_results.get('ml_predictions', {}).get(symbol, 0)
                
                # Ï¢ÖÌï© Ï†êÏàò Í≥ÑÏÇ∞
                total_score = (buffett_score + lynch_score + graham_score) / 3 + ai_bonus * 0.1
                
                strategy_scores[symbol] = {
                    'total_score': total_score,
                    'buffett_score': buffett_score,
                    'lynch_score': lynch_score,
                    'graham_score': graham_score,
                    'ai_bonus': ai_bonus
                }
            
            # Top 5 ÏÑ†Ï†ï
            top5 = sorted(strategy_scores.items(), key=lambda x: x[1]['total_score'], reverse=True)[:5]
            
            final_recommendations = {
                'top5_stocks': top5,
                'analysis_timestamp': datetime.now().isoformat(),
                'total_analyzed': len(strategy_scores),
                'recommendation_reason': "Ìà¨Ïûê ÎåÄÍ∞Ä Ï†ÑÎûµ + AI Î∂ÑÏÑù Ï¢ÖÌï© Í≤∞Í≥º"
            }
            
            return final_recommendations
            
        except Exception as e:
            logger.error(f"ÏµúÏ¢Ö Ï∂îÏ≤ú ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return {}

    def _save_and_notify_results(self, results: Dict):
        """Í≤∞Í≥º Ï†ÄÏû• Î∞è ÏïåÎ¶º"""
        try:
            # Í≤∞Í≥º ÌååÏùº Ï†ÄÏû•
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"analysis_results_{timestamp}.json"
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(results, f, ensure_ascii=False, indent=2)
            
            # Í∞ÑÎã®Ìïú Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
            self._generate_simple_report(results, filename)
            
            # ÏΩòÏÜî Ï∂úÎ†•
            self._print_results_summary(results)
            
            logger.info(f"üìÑ Í≤∞Í≥º Ï†ÄÏû• ÏôÑÎ£å: {filename}")
            
        except Exception as e:
            logger.error(f"Í≤∞Í≥º Ï†ÄÏû• Ïã§Ìå®: {e}")

    def _generate_simple_report(self, results: Dict, filename: str):
        """Í∞ÑÎã®Ìïú Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±"""
        try:
            report_filename = filename.replace('.json', '_report.txt')
            
            with open(report_filename, 'w', encoding='utf-8') as f:
                f.write("üéØ ÏûêÎèôÌôî Ìà¨Ïûê Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏\n")
                f.write("=" * 50 + "\n\n")
                f.write(f"Î∂ÑÏÑù ÏãúÍ∞Ñ: {results.get('analysis_timestamp', 'N/A')}\n")
                f.write(f"Î∂ÑÏÑù Ï¢ÖÎ™© Ïàò: {results.get('total_analyzed', 0)}Í∞ú\n\n")
                
                f.write("üìà Top 5 Ï∂îÏ≤ú Ï¢ÖÎ™©:\n")
                f.write("-" * 30 + "\n")
                
                for i, (symbol, scores) in enumerate(results.get('top5_stocks', []), 1):
                    f.write(f"{i}. {symbol}\n")
                    f.write(f"   Ï¢ÖÌï© Ï†êÏàò: {scores['total_score']:.2f}\n")
                    f.write(f"   Î≤ÑÌïè Ï†êÏàò: {scores['buffett_score']:.2f}\n")
                    f.write(f"   Î¶∞Ïπò Ï†êÏàò: {scores['lynch_score']:.2f}\n")
                    f.write(f"   Í∑∏Î†àÏù¥ÏóÑ Ï†êÏàò: {scores['graham_score']:.2f}\n")
                    f.write(f"   AI Î≥¥ÎÑàÏä§: {scores['ai_bonus']:.2f}\n\n")
                
                f.write(f"ÏÑ†Ï†ï Í∑ºÍ±∞: {results.get('recommendation_reason', 'N/A')}\n")
            
            logger.info(f"üìä Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± ÏôÑÎ£å: {report_filename}")
            
        except Exception as e:
            logger.error(f"Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")

    def _print_results_summary(self, results: Dict):
        """Í≤∞Í≥º ÏöîÏïΩ Ï∂úÎ†•"""
        print("\n" + "="*60)
        print("üéØ ÏûêÎèôÌôî Ìà¨Ïûê Î∂ÑÏÑù Í≤∞Í≥º")
        print("="*60)
        print(f"üìÖ Î∂ÑÏÑù ÏãúÍ∞Ñ: {results.get('analysis_timestamp', 'N/A')}")
        print(f"üìä Î∂ÑÏÑù Ï¢ÖÎ™©: {results.get('total_analyzed', 0)}Í∞ú")
        print("\nüìà Top 5 Ï∂îÏ≤ú Ï¢ÖÎ™©:")
        print("-"*40)
        
        for i, (symbol, scores) in enumerate(results.get('top5_stocks', []), 1):
            print(f"{i}. {symbol:8} | Ï†êÏàò: {scores['total_score']:.2f}")
        
        print("="*60 + "\n")

    def _check_system_resources(self) -> bool:
        """ÏãúÏä§ÌÖú Î¶¨ÏÜåÏä§ Ï≤¥ÌÅ¨"""
        try:
            import psutil
            
            cpu_percent = psutil.cpu_percent(interval=1)
            memory_percent = psutil.virtual_memory().percent
            
            if cpu_percent > self.config.emergency_stop_cpu:
                logger.warning(f"‚ö†Ô∏è CPU ÏÇ¨Ïö©Î•† ÎÜíÏùå: {cpu_percent}%")
                return False
                
            if memory_percent > self.config.emergency_stop_memory:
                logger.warning(f"‚ö†Ô∏è Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Î•† ÎÜíÏùå: {memory_percent}%")
                return False
                
            return True
            
        except ImportError:
            return True  # psutil ÏóÜÏúºÎ©¥ ÏùºÎã® ÏßÑÌñâ

    def _background_monitor(self):
        """Î∞±Í∑∏ÎùºÏö¥Îìú ÏãúÏä§ÌÖú Î™®ÎãàÌÑ∞ÎßÅ"""
        while self.is_running:
            try:
                # ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï≤¥ÌÅ¨
                if not self._check_system_resources():
                    logger.warning("‚ö†Ô∏è ÏãúÏä§ÌÖú Î∂ÄÌïòÎ°ú Ïù∏Ìïú ÏùºÏãú Ï†ïÏßÄ")
                    time.sleep(300)  # 5Î∂Ñ ÎåÄÍ∏∞
                    continue
                
                # ÌôúÏÑ± ÏûëÏóÖ Î™®ÎãàÌÑ∞ÎßÅ
                if len(self.active_tasks) > self.config.max_concurrent_tasks:
                    logger.warning(f"‚ö†Ô∏è ÎèôÏãú ÏûëÏóÖ Ï†úÌïú Ï¥àÍ≥º: {len(self.active_tasks)}")
                
                time.sleep(60)  # 1Î∂ÑÎßàÎã§ Ï≤¥ÌÅ¨
                
            except Exception as e:
                logger.error(f"Î™®ÎãàÌÑ∞ÎßÅ Ïò§Î•ò: {e}")
                time.sleep(60)

    def _hourly_system_check(self):
        """Îß§ÏãúÍ∞Ñ ÏãúÏä§ÌÖú Ï≤¥ÌÅ¨"""
        logger.info("üîç ÏãúÍ∞ÑÎ≥Ñ ÏãúÏä§ÌÖú Ï≤¥ÌÅ¨")
        
        try:
            import psutil
            
            # ÏãúÏä§ÌÖú ÏÉÅÌÉú Î°úÍπÖ
            cpu = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory().percent
            
            logger.info(f"üíª ÏãúÏä§ÌÖú ÏÉÅÌÉú - CPU: {cpu}%, RAM: {memory}%")
            
            # ÎîîÏä§ÌÅ¨ Í≥µÍ∞Ñ Ï≤¥ÌÅ¨
            disk = psutil.disk_usage('/').percent
            if disk > 90:
                logger.warning(f"‚ö†Ô∏è ÎîîÏä§ÌÅ¨ Í≥µÍ∞Ñ Î∂ÄÏ°±: {disk}%")
            
        except ImportError:
            logger.info("üíª ÏãúÏä§ÌÖú Î™®ÎãàÌÑ∞ÎßÅ ÎèÑÍµ¨ ÏóÜÏùå")

    def _quick_monitoring(self):
        """30Î∂ÑÎßàÎã§ Í∞ÑÎã® Î™®ÎãàÌÑ∞ÎßÅ"""
        current_time = datetime.now()
        
        if self.last_analysis_time:
            time_since_last = current_time - self.last_analysis_time
            if time_since_last > timedelta(hours=25):  # 25ÏãúÍ∞Ñ Ïù¥ÏÉÅ Î∂ÑÏÑù ÏóÜÏùå
                logger.warning("‚ö†Ô∏è Ïû•ÏãúÍ∞Ñ Î∂ÑÏÑù ÏóÜÏùå - ÏàòÎèô Ï†êÍ≤Ä ÌïÑÏöî")

    def _get_extended_symbol_list(self) -> List[str]:
        """ÌôïÏû•Îêú Ï¢ÖÎ™© Î¶¨Ïä§Ìä∏ (Ï£ºÍ∞Ñ Ïã¨Ï∏µ Î∂ÑÏÑùÏö©)"""
        return [
            # ÎØ∏Íµ≠ Ï£ºÏöî Ï¢ÖÎ™©
            'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'NVDA', 'META', 'NFLX',
            'CRM', 'ADBE', 'INTC', 'AMD', 'ORCL', 'IBM', 'CSCO',
            
            # ÌïúÍµ≠ Ï£ºÏöî Ï¢ÖÎ™©
            '005930.KS', '000660.KS', '035420.KS', '005380.KS', '051910.KS',
            '035720.KS', '028260.KS', '006400.KS', '068270.KS', '105560.KS'
        ]

    def _perform_deep_analysis(self, symbols: List[str]) -> Dict:
        """Ïã¨Ï∏µ Î∂ÑÏÑù ÏàòÌñâ"""
        # Í∞ÑÎã®ÌôîÎêú Î≤ÑÏ†Ñ - Ïã§Ï†úÎ°úÎäî Îçî Î≥µÏû°Ìïú Î∂ÑÏÑù
        return {"deep_analysis": "completed", "symbols": len(symbols)}

    def _run_backtest(self, analysis_results: Dict) -> Dict:
        """Î∞±ÌÖåÏä§ÌåÖ Ïã§Ìñâ"""
        return {"backtest": "completed"}

    def _optimize_strategies(self, backtest_results: Dict) -> Dict:
        """Ï†ÑÎûµ ÏµúÏ†ÅÌôî"""
        return {"optimization": "completed"}

    def _generate_weekly_report(self, deep_results: Dict, optimized_strategies: Dict):
        """Ï£ºÍ∞Ñ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±"""
        timestamp = datetime.now().strftime("%Y%m%d")
        filename = f"weekly_report_{timestamp}.txt"
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write("üìà Ï£ºÍ∞Ñ Ïã¨Ï∏µ Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏\n")
            f.write("=" * 50 + "\n")
            f.write(f"ÏÉùÏÑ± ÎÇ†Ïßú: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write("Ï£ºÍ∞Ñ Î∂ÑÏÑù ÏôÑÎ£å\n")

    def stop_automation(self):
        """ÏûêÎèôÌôî ÏãúÏä§ÌÖú Ï§ëÏßÄ"""
        logger.info("üõë ÏûêÎèôÌôî ÏãúÏä§ÌÖú Ï§ëÏßÄ")
        self.is_running = False
        schedule.clear()

def main():
    """Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò"""
    print("üöÄ ÏôÑÏ†Ñ ÏûêÎèôÌôî Ìà¨Ïûê Î∂ÑÏÑù ÏãúÏä§ÌÖú")
    print("=" * 50)
    
    # ÏÑ§Ï†ï Î°úÎìú
    config = AutomationConfig()
    
    # ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî
    master_system = AutomatedMasterSystem(config)
    
    try:
        # Ï¶âÏãú Ï≤´ Î∂ÑÏÑù Ïã§Ìñâ
        print("üéØ Ï≤´ Î∂ÑÏÑùÏùÑ Ïã§ÌñâÌï©ÎãàÎã§...")
        master_system._run_daily_analysis()
        
        print("‚è∞ ÏûêÎèôÌôî Ïä§ÏºÄÏ§ÑÎü¨Î•º ÏãúÏûëÌï©ÎãàÎã§...")
        print(f"üìÖ Îß§Ïùº {config.daily_analysis_time}Ïóê ÏûêÎèô Î∂ÑÏÑù Ïã§Ìñâ")
        print(f"üìÖ Îß§Ï£º ÏõîÏöîÏùº 10:00Ïóê Ïã¨Ï∏µ Î∂ÑÏÑù Ïã§Ìñâ")
        print("üîÑ Ctrl+CÎ°ú Ï§ëÏßÄÌï† Ïàò ÏûàÏäµÎãàÎã§.")
        
        # ÏûêÎèôÌôî ÏãúÏûë
        master_system.start_automation()
        
    except KeyboardInterrupt:
        print("\nüëã ÏãúÏä§ÌÖúÏùÑ ÏïàÏ†ÑÌïòÍ≤å Ï¢ÖÎ£åÌï©ÎãàÎã§...")
        master_system.stop_automation()
    except Exception as e:
        logger.error(f"‚ùå ÏãúÏä§ÌÖú Ïò§Î•ò: {e}")
        master_system.stop_automation()

if __name__ == "__main__":
    main() 