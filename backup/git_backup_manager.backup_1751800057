#!/usr/bin/env python3
"""
ğŸ”„ ê¹ƒí—ˆë¸Œ ìë™ ë°±ì—… ê´€ë¦¬ì
========================

ê¹ƒí—ˆë¸Œ ì €ì¥ì†Œë¥¼ í†µí•œ ìë™ ë°ì´í„° ë°±ì—… ì‹œìŠ¤í…œì…ë‹ˆë‹¤.
ì •ê¸°ì ì¸ ì»¤ë°‹, í‘¸ì‹œ, ë¸Œëœì¹˜ ê´€ë¦¬, ì¶©ëŒ í•´ê²°ì„ ìë™í™”í•©ë‹ˆë‹¤.
"""

import asyncio
import logging
import os
import subprocess
import json
import shutil
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path
import git
from git import Repo, GitCommandError
import yaml

logger = logging.getLogger(__name__)

class GitBackupManager:
    """ê¹ƒí—ˆë¸Œ ìë™ ë°±ì—… ê´€ë¦¬ì"""
    
    def __init__(self, 
                 repo_path: str = ".",
                 remote_url: str = None,
                 backup_branch: str = "backup",
                 auto_backup_interval: int = 3600,  # 1ì‹œê°„
                 max_backup_history: int = 30):  # 30ê°œ ë°±ì—… ìœ ì§€
        
        self.repo_path = Path(repo_path)
        self.remote_url = remote_url
        self.backup_branch = backup_branch
        self.auto_backup_interval = auto_backup_interval
        self.max_backup_history = max_backup_history
        
        # ë°±ì—… ì„¤ì •
        self.backup_config = {
            'include_patterns': [
                '*.py', '*.json', '*.yaml', '*.yml', '*.md', '*.txt',
                'requirements.txt', 'pyproject.toml', 'setup.py'
            ],
            'exclude_patterns': [
                '__pycache__', '*.pyc', '*.pyo', '*.pyd',
                '.git', '.env', '*.log', 'temp_*', 'cache_*',
                'node_modules', '.DS_Store', 'Thumbs.db'
            ],
            'data_dirs': ['data', 'reports', 'logs', 'models'],
            'config_dirs': ['config', 'src/config']
        }
        
        # ë°±ì—… ìƒíƒœ
        self.is_backup_running = False
        self.last_backup_time = None
        self.backup_task = None
        
        # ê¹ƒ ì €ì¥ì†Œ
        self.repo = None
        self._initialize_repo()
        
        logger.info("ğŸ”„ ê¹ƒí—ˆë¸Œ ìë™ ë°±ì—… ê´€ë¦¬ì ì´ˆê¸°í™” ì™„ë£Œ")
    
    def _initialize_repo(self):
        """ê¹ƒ ì €ì¥ì†Œ ì´ˆê¸°í™”"""
        try:
            if (self.repo_path / '.git').exists():
                self.repo = Repo(self.repo_path)
                logger.info(f"ê¸°ì¡´ ê¹ƒ ì €ì¥ì†Œ ë¡œë“œ: {self.repo_path}")
            else:
                self.repo = Repo.init(self.repo_path)
                logger.info(f"ìƒˆ ê¹ƒ ì €ì¥ì†Œ ì´ˆê¸°í™”: {self.repo_path}")
            
            # ì›ê²© ì €ì¥ì†Œ ì„¤ì •
            if self.remote_url:
                self._setup_remote()
            
        except Exception as e:
            logger.error(f"ê¹ƒ ì €ì¥ì†Œ ì´ˆê¸°í™” ì˜¤ë¥˜: {e}")
            raise
    
    def _setup_remote(self):
        """ì›ê²© ì €ì¥ì†Œ ì„¤ì •"""
        try:
            if 'origin' not in [remote.name for remote in self.repo.remotes]:
                self.repo.create_remote('origin', self.remote_url)
                logger.info(f"ì›ê²© ì €ì¥ì†Œ ì¶”ê°€: {self.remote_url}")
            else:
                origin = self.repo.remotes.origin
                origin.set_url(self.remote_url)
                logger.info(f"ì›ê²© ì €ì¥ì†Œ URL ì—…ë°ì´íŠ¸: {self.remote_url}")
        
        except Exception as e:
            logger.error(f"ì›ê²© ì €ì¥ì†Œ ì„¤ì • ì˜¤ë¥˜: {e}")
    
    async def start_auto_backup(self):
        """ìë™ ë°±ì—… ì‹œì‘"""
        if self.is_backup_running:
            return
        
        self.is_backup_running = True
        self.backup_task = asyncio.create_task(self._auto_backup_loop())
        
        logger.info("ğŸš€ ìë™ ë°±ì—… ì‹œì‘")
    
    async def stop_auto_backup(self):
        """ìë™ ë°±ì—… ì¤‘ì§€"""
        self.is_backup_running = False
        if self.backup_task:
            self.backup_task.cancel()
            try:
                await self.backup_task
            except asyncio.CancelledError:
                pass
        
        logger.info("ğŸ›‘ ìë™ ë°±ì—… ì¤‘ì§€")
    
    async def _auto_backup_loop(self):
        """ìë™ ë°±ì—… ë£¨í”„"""
        while self.is_backup_running:
            try:
                # ë°±ì—… ì‹¤í–‰
                await self.create_backup()
                
                # ëŒ€ê¸°
                await asyncio.sleep(self.auto_backup_interval)
                
            except Exception as e:
                logger.error(f"ìë™ ë°±ì—… ì˜¤ë¥˜: {e}")
                await asyncio.sleep(300)  # 5ë¶„ í›„ ì¬ì‹œë„
    
    async def create_backup(self, backup_name: str = None) -> bool:
        """ë°±ì—… ìƒì„±"""
        try:
            if not backup_name:
                backup_name = f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            logger.info(f"ğŸ’¾ ë°±ì—… ìƒì„± ì‹œì‘: {backup_name}")
            
            # 1. ë³€ê²½ì‚¬í•­ í™•ì¸
            if not self._has_changes():
                logger.info("ë³€ê²½ì‚¬í•­ì´ ì—†ì–´ ë°±ì—…ì„ ê±´ë„ˆëœë‹ˆë‹¤.")
                return True
            
            # 2. ë°±ì—… ë¸Œëœì¹˜ ìƒì„±/ì „í™˜
            await self._create_backup_branch(backup_name)
            
            # 3. íŒŒì¼ ì¶”ê°€
            await self._add_files()
            
            # 4. ì»¤ë°‹
            commit_message = f"ğŸ”„ ìë™ ë°±ì—…: {backup_name}\n\n- ë°±ì—… ì‹œê°„: {datetime.now().isoformat()}\n- ë³€ê²½ëœ íŒŒì¼: {self._get_changed_files_count()}ê°œ"
            await self._commit_changes(commit_message)
            
            # 5. ì›ê²© ì €ì¥ì†Œ í‘¸ì‹œ
            await self._push_to_remote()
            
            # 6. ë°±ì—… íˆìŠ¤í† ë¦¬ ì •ë¦¬
            await self._cleanup_old_backups()
            
            self.last_backup_time = datetime.now()
            logger.info(f"âœ… ë°±ì—… ì™„ë£Œ: {backup_name}")
            
            return True
            
        except Exception as e:
            logger.error(f"ë°±ì—… ìƒì„± ì‹¤íŒ¨: {e}")
            return False
    
    def _has_changes(self) -> bool:
        """ë³€ê²½ì‚¬í•­ í™•ì¸"""
        try:
            # ìŠ¤í…Œì´ì§•ë˜ì§€ ì•Šì€ ë³€ê²½ì‚¬í•­
            unstaged = self.repo.index.diff(None)
            
            # ìŠ¤í…Œì´ì§•ëœ ë³€ê²½ì‚¬í•­
            staged = self.repo.index.diff('HEAD')
            
            # ì¶”ì ë˜ì§€ ì•ŠëŠ” íŒŒì¼
            untracked = self.repo.untracked_files
            
            return len(unstaged) > 0 or len(staged) > 0 or len(untracked) > 0
            
        except Exception as e:
            logger.error(f"ë³€ê²½ì‚¬í•­ í™•ì¸ ì˜¤ë¥˜: {e}")
            return False
    
    async def _create_backup_branch(self, backup_name: str):
        """ë°±ì—… ë¸Œëœì¹˜ ìƒì„±/ì „í™˜"""
        try:
            # í˜„ì¬ ë¸Œëœì¹˜ ì €ì¥
            current_branch = self.repo.active_branch.name
            
            # ë°±ì—… ë¸Œëœì¹˜ ìƒì„±
            branch_name = f"{self.backup_branch}/{backup_name}"
            
            if branch_name in [branch.name for branch in self.repo.branches]:
                # ê¸°ì¡´ ë¸Œëœì¹˜ë¡œ ì „í™˜
                self.repo.heads[branch_name].checkout()
                logger.info(f"ê¸°ì¡´ ë°±ì—… ë¸Œëœì¹˜ë¡œ ì „í™˜: {branch_name}")
            else:
                # ìƒˆ ë¸Œëœì¹˜ ìƒì„±
                new_branch = self.repo.create_head(branch_name)
                new_branch.checkout()
                logger.info(f"ìƒˆ ë°±ì—… ë¸Œëœì¹˜ ìƒì„±: {branch_name}")
            
            # main ë¸Œëœì¹˜ë¡œ ëŒì•„ê°€ê¸°
            self.repo.heads[current_branch].checkout()
            
        except Exception as e:
            logger.error(f"ë°±ì—… ë¸Œëœì¹˜ ìƒì„± ì˜¤ë¥˜: {e}")
            raise
    
    async def _add_files(self):
        """íŒŒì¼ ì¶”ê°€"""
        try:
            # ë°±ì—…í•  íŒŒì¼ë“¤ ì°¾ê¸°
            files_to_add = self._get_files_to_backup()
            
            if not files_to_add:
                logger.info("ë°±ì—…í•  íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
                return
            
            # íŒŒì¼ ì¶”ê°€
            for file_path in files_to_add:
                try:
                    self.repo.index.add([str(file_path)])
                    logger.debug(f"íŒŒì¼ ì¶”ê°€: {file_path}")
                except Exception as e:
                    logger.warning(f"íŒŒì¼ ì¶”ê°€ ì‹¤íŒ¨: {file_path} - {e}")
            
            logger.info(f"ì´ {len(files_to_add)}ê°œ íŒŒì¼ ì¶”ê°€ë¨")
            
        except Exception as e:
            logger.error(f"íŒŒì¼ ì¶”ê°€ ì˜¤ë¥˜: {e}")
            raise
    
    def _get_files_to_backup(self) -> List[Path]:
        """ë°±ì—…í•  íŒŒì¼ ëª©ë¡ ìƒì„±"""
        files_to_backup = []
        
        for pattern in self.backup_config['include_patterns']:
            for file_path in self.repo_path.rglob(pattern):
                if self._should_backup_file(file_path):
                    files_to_backup.append(file_path)
        
        # ë°ì´í„° ë””ë ‰í† ë¦¬ ì¶”ê°€
        for data_dir in self.backup_config['data_dirs']:
            data_path = self.repo_path / data_dir
            if data_path.exists():
                for file_path in data_path.rglob('*'):
                    if file_path.is_file() and self._should_backup_file(file_path):
                        files_to_backup.append(file_path)
        
        return list(set(files_to_backup))  # ì¤‘ë³µ ì œê±°
    
    def _should_backup_file(self, file_path: Path) -> bool:
        """íŒŒì¼ ë°±ì—… ì—¬ë¶€ í™•ì¸"""
        # ì œì™¸ íŒ¨í„´ ì²´í¬
        for exclude_pattern in self.backup_config['exclude_patterns']:
            if exclude_pattern in str(file_path):
                return False
        
        # íŒŒì¼ í¬ê¸° ì²´í¬ (100MB ì´ìƒ ì œì™¸)
        if file_path.stat().st_size > 100 * 1024 * 1024:
            return False
        
        return True
    
    async def _commit_changes(self, message: str):
        """ë³€ê²½ì‚¬í•­ ì»¤ë°‹"""
        try:
            if not self.repo.index.diff('HEAD'):
                logger.info("ì»¤ë°‹í•  ë³€ê²½ì‚¬í•­ì´ ì—†ìŠµë‹ˆë‹¤.")
                return
            
            self.repo.index.commit(message)
            logger.info(f"ì»¤ë°‹ ì™„ë£Œ: {message[:50]}...")
            
        except Exception as e:
            logger.error(f"ì»¤ë°‹ ì˜¤ë¥˜: {e}")
            raise
    
    async def _push_to_remote(self):
        """ì›ê²© ì €ì¥ì†Œë¡œ í‘¸ì‹œ"""
        try:
            if 'origin' not in [remote.name for remote in self.repo.remotes]:
                logger.warning("ì›ê²© ì €ì¥ì†Œê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
                return
            
            origin = self.repo.remotes.origin
            
            # í˜„ì¬ ë¸Œëœì¹˜ í‘¸ì‹œ
            current_branch = self.repo.active_branch.name
            origin.push(current_branch)
            
            # ë°±ì—… ë¸Œëœì¹˜ë“¤ í‘¸ì‹œ
            for branch in self.repo.branches:
                if branch.name.startswith(f"{self.backup_branch}/"):
                    try:
                        origin.push(branch.name)
                        logger.info(f"ë°±ì—… ë¸Œëœì¹˜ í‘¸ì‹œ: {branch.name}")
                    except Exception as e:
                        logger.warning(f"ë°±ì—… ë¸Œëœì¹˜ í‘¸ì‹œ ì‹¤íŒ¨: {branch.name} - {e}")
            
            logger.info("ì›ê²© ì €ì¥ì†Œ í‘¸ì‹œ ì™„ë£Œ")
            
        except Exception as e:
            logger.error(f"í‘¸ì‹œ ì˜¤ë¥˜: {e}")
            raise
    
    async def _cleanup_old_backups(self):
        """ì˜¤ë˜ëœ ë°±ì—… ì •ë¦¬"""
        try:
            backup_branches = [
                branch for branch in self.repo.branches 
                if branch.name.startswith(f"{self.backup_branch}/")
            ]
            
            if len(backup_branches) <= self.max_backup_history:
                return
            
            # ì˜¤ë˜ëœ ìˆœìœ¼ë¡œ ì •ë ¬
            backup_branches.sort(key=lambda b: b.commit.committed_datetime)
            
            # ì´ˆê³¼ë¶„ ì‚­ì œ
            branches_to_delete = backup_branches[:-self.max_backup_history]
            
            for branch in branches_to_delete:
                try:
                    self.repo.delete_head(branch.name, force=True)
                    logger.info(f"ì˜¤ë˜ëœ ë°±ì—… ë¸Œëœì¹˜ ì‚­ì œ: {branch.name}")
                except Exception as e:
                    logger.warning(f"ë°±ì—… ë¸Œëœì¹˜ ì‚­ì œ ì‹¤íŒ¨: {branch.name} - {e}")
            
            logger.info(f"ë°±ì—… ì •ë¦¬ ì™„ë£Œ: {len(branches_to_delete)}ê°œ ì‚­ì œ")
            
        except Exception as e:
            logger.error(f"ë°±ì—… ì •ë¦¬ ì˜¤ë¥˜: {e}")
    
    def _get_changed_files_count(self) -> int:
        """ë³€ê²½ëœ íŒŒì¼ ìˆ˜ ë°˜í™˜"""
        try:
            unstaged = len(self.repo.index.diff(None))
            staged = len(self.repo.index.diff('HEAD'))
            untracked = len(self.repo.untracked_files)
            return unstaged + staged + untracked
        except:
            return 0
    
    async def restore_backup(self, backup_name: str) -> bool:
        """ë°±ì—… ë³µì›"""
        try:
            branch_name = f"{self.backup_branch}/{backup_name}"
            
            if branch_name not in [branch.name for branch in self.repo.branches]:
                logger.error(f"ë°±ì—… ë¸Œëœì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {branch_name}")
                return False
            
            # ë°±ì—… ë¸Œëœì¹˜ë¡œ ì „í™˜
            self.repo.heads[branch_name].checkout()
            
            # íŒŒì¼ ë³µì›
            await self._restore_files_from_branch(branch_name)
            
            # main ë¸Œëœì¹˜ë¡œ ëŒì•„ê°€ê¸°
            self.repo.heads['main'].checkout()
            
            logger.info(f"âœ… ë°±ì—… ë³µì› ì™„ë£Œ: {backup_name}")
            return True
            
        except Exception as e:
            logger.error(f"ë°±ì—… ë³µì› ì‹¤íŒ¨: {e}")
            return False
    
    async def _restore_files_from_branch(self, branch_name: str):
        """ë¸Œëœì¹˜ì—ì„œ íŒŒì¼ ë³µì›"""
        try:
            # ë°±ì—… ë¸Œëœì¹˜ì˜ íŒŒì¼ë“¤ì„ í˜„ì¬ ë¸Œëœì¹˜ë¡œ ë³µì‚¬
            backup_branch = self.repo.heads[branch_name]
            
            for file_path in self.repo_path.rglob('*'):
                if file_path.is_file() and self._should_backup_file(file_path):
                    try:
                        # ë°±ì—… ë¸Œëœì¹˜ì˜ íŒŒì¼ ë‚´ìš© ê°€ì ¸ì˜¤ê¸°
                        file_content = backup_branch.commit.tree[str(file_path.relative_to(self.repo_path))].data_stream.read()
                        
                        # íŒŒì¼ ë³µì›
                        with open(file_path, 'wb') as f:
                            f.write(file_content)
                        
                        logger.debug(f"íŒŒì¼ ë³µì›: {file_path}")
                        
                    except Exception as e:
                        logger.warning(f"íŒŒì¼ ë³µì› ì‹¤íŒ¨: {file_path} - {e}")
            
            logger.info("íŒŒì¼ ë³µì› ì™„ë£Œ")
            
        except Exception as e:
            logger.error(f"íŒŒì¼ ë³µì› ì˜¤ë¥˜: {e}")
            raise
    
    def get_backup_list(self) -> List[Dict[str, Any]]:
        """ë°±ì—… ëª©ë¡ ë°˜í™˜"""
        try:
            backup_list = []
            
            for branch in self.repo.branches:
                if branch.name.startswith(f"{self.backup_branch}/"):
                    backup_name = branch.name.replace(f"{self.backup_branch}/", "")
                    
                    backup_list.append({
                        'name': backup_name,
                        'branch': branch.name,
                        'created_at': branch.commit.committed_datetime.isoformat(),
                        'commit_hash': branch.commit.hexsha[:8],
                        'message': branch.commit.message.split('\n')[0]
                    })
            
            # ìƒì„±ì¼ ê¸°ì¤€ ì •ë ¬
            backup_list.sort(key=lambda x: x['created_at'], reverse=True)
            
            return backup_list
            
        except Exception as e:
            logger.error(f"ë°±ì—… ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return []
    
    def get_backup_status(self) -> Dict[str, Any]:
        """ë°±ì—… ìƒíƒœ ë°˜í™˜"""
        return {
            'is_running': self.is_backup_running,
            'last_backup': self.last_backup_time.isoformat() if self.last_backup_time else None,
            'backup_interval': self.auto_backup_interval,
            'max_history': self.max_backup_history,
            'backup_count': len(self.get_backup_list()),
            'has_changes': self._has_changes(),
            'changed_files_count': self._get_changed_files_count()
        }
    
    def save_backup_report(self, output_dir: str = "reports/backup"):
        """ë°±ì—… ë¦¬í¬íŠ¸ ì €ì¥"""
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        report = {
            'timestamp': datetime.now().isoformat(),
            'status': self.get_backup_status(),
            'backup_list': self.get_backup_list(),
            'config': self.backup_config
        }
        
        report_path = output_path / f"backup_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False, default=str)
        
        logger.info(f"ğŸ“Š ë°±ì—… ë¦¬í¬íŠ¸ ì €ì¥: {report_path}")

# ì „ì—­ ì¸ìŠ¤í„´ìŠ¤
git_backup_manager = GitBackupManager()

async def start_git_backup():
    """ê¹ƒ ë°±ì—… ì‹œì‘"""
    await git_backup_manager.start_auto_backup()

async def stop_git_backup():
    """ê¹ƒ ë°±ì—… ì¤‘ì§€"""
    await git_backup_manager.stop_auto_backup()

def get_backup_status():
    """ë°±ì—… ìƒíƒœ ì¡°íšŒ"""
    return git_backup_manager.get_backup_status()

def get_backup_list():
    """ë°±ì—… ëª©ë¡ ì¡°íšŒ"""
    return git_backup_manager.get_backup_list()

async def create_manual_backup(backup_name: str = None):
    """ìˆ˜ë™ ë°±ì—… ìƒì„±"""
    return await git_backup_manager.create_backup(backup_name)

async def restore_backup(backup_name: str):
    """ë°±ì—… ë³µì›"""
    return await git_backup_manager.restore_backup(backup_name) 