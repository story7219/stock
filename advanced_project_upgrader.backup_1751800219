# advanced_project_upgrader.py - ê³ ê¸‰ í”„ë¡œì íŠ¸ ì „ì²´ A+ ìˆ˜ì¤€ ì—…ê·¸ë ˆì´ë“œ
"""
ğŸ¯ ê³ ê¸‰ í”„ë¡œì íŠ¸ ì „ì²´ íŒŒì¼ A+ ìˆ˜ì¤€ ì—…ê·¸ë ˆì´ë“œ ì‹œìŠ¤í…œ v2.0
- ì „ëµ: continuous_error_fix.py ìˆ˜ì¤€(A+ 95/100ì )ìœ¼ë¡œ ëª¨ë“  íŒŒì¼ ì™„ì „ ì—…ê·¸ë ˆì´ë“œ
- ìµœì‹  Python 3.11+ ë¬¸ë²•, íƒ€ì… íŒíŠ¸, ë¹„ë™ê¸° ì²˜ë¦¬, ì—ëŸ¬ ì²˜ë¦¬, ë¬¸ì„œí™” ì™„ë²½ ì ìš©
- ì—­í• : í”„ë¡œì íŠ¸ ì „ì²´ íŒŒì¼ì˜ í’ˆì§ˆì„ ì„¸ê³„ ìµœê³  ìˆ˜ì¤€ìœ¼ë¡œ í†µì¼
"""
from __future__ import annotations

import asyncio
import ast
import json
import logging
import re
import shutil
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple, Final, TypeAlias
from dataclasses import dataclass, field
from enum import StrEnum
import aiofiles

# íƒ€ì… ë³„ì¹­
FileQuality: TypeAlias = Dict[str, Any]
UpgradeResult: TypeAlias = Dict[str, Any]

class FileCategory(StrEnum):
    """íŒŒì¼ ì¹´í…Œê³ ë¦¬ ì—´ê±°í˜•"""
    MAIN_EXECUTABLE = "main_executable"      # ë©”ì¸ ì‹¤í–‰ íŒŒì¼
    CORE_MODULE = "core_module"              # í•µì‹¬ ëª¨ë“ˆ
    DATA_PROCESSOR = "data_processor"        # ë°ì´í„° ì²˜ë¦¬ê¸°
    ANALYSIS_ENGINE = "analysis_engine"      # ë¶„ì„ ì—”ì§„
    API_INTEGRATION = "api_integration"      # API ì—°ë™
    UTILITY = "utility"                      # ìœ í‹¸ë¦¬í‹°
    TEST = "test"                            # í…ŒìŠ¤íŠ¸ íŒŒì¼

class QualityLevel(StrEnum):
    """í’ˆì§ˆ ìˆ˜ì¤€ ì—´ê±°í˜•"""
    A_PLUS = "A+"    # 95-100ì  (continuous_error_fix.py ìˆ˜ì¤€)
    A = "A"          # 85-94ì 
    B = "B"          # 70-84ì 
    C = "C"          # 50-69ì 
    D = "D"          # 30-49ì 
    F = "F"          # 0-29ì 

@dataclass(slots=True)
class FileAnalysis:
    """íŒŒì¼ ë¶„ì„ ê²°ê³¼ í´ë˜ìŠ¤"""
    file_path: Path
    category: FileCategory
    current_quality: QualityLevel
    current_score: int
    target_score: int = 95
    upgrade_needed: bool = True
    issues: List[str] = field(default_factory=list)
    improvements: List[str] = field(default_factory=list)

@dataclass(slots=True)
class UpgradeMetrics:
    """ì—…ê·¸ë ˆì´ë“œ ë©”íŠ¸ë¦­ í´ë˜ìŠ¤"""
    total_files: int = 0
    files_upgraded: int = 0
    files_skipped: int = 0
    total_score_improvement: int = 0
    start_time: float = field(default_factory=time.time)
    
    @property
    def completion_rate(self) -> float:
        """ì™„ë£Œìœ¨ ê³„ì‚°"""
        return (self.files_upgraded / self.total_files * 100) if self.total_files > 0 else 0.0
    
    @property
    def average_score_improvement(self) -> float:
        """í‰ê·  ì ìˆ˜ ê°œì„ ìœ¨"""
        return (self.total_score_improvement / self.files_upgraded) if self.files_upgraded > 0 else 0.0

class AdvancedProjectUpgrader:
    """ê³ ê¸‰ í”„ë¡œì íŠ¸ ì „ì²´ ì—…ê·¸ë ˆì´ë“œ í´ë˜ìŠ¤"""
    
    def __init__(self, project_root: Path) -> None:
        """ì—…ê·¸ë ˆì´ë” ì´ˆê¸°í™”"""
        self.project_root = project_root
        self.metrics = UpgradeMetrics()
        self.logger = self._setup_logger()
        
        # ì œì™¸í•  íŒŒì¼/ë””ë ‰í† ë¦¬ íŒ¨í„´
        self.exclude_patterns: Final[Set[str]] = {
            '__pycache__', '.git', 'venv', '.venv', 'node_modules',
            '.pytest_cache', '.mypy_cache', 'backup_code_fixes',
            'backups', 'logs', 'results', 'outputs', 'charts'
        }
        
        # íŒŒì¼ ì¹´í…Œê³ ë¦¬ ë§¤í•‘
        self.category_patterns: Final[Dict[FileCategory, List[str]]] = {
            FileCategory.MAIN_EXECUTABLE: ['main', 'run_', 'auto_'],
            FileCategory.CORE_MODULE: ['core/', 'unified_'],
            FileCategory.DATA_PROCESSOR: ['data/', 'processor', 'collector'],
            FileCategory.ANALYSIS_ENGINE: ['analysis/', 'analyzer', 'strategy'],
            FileCategory.API_INTEGRATION: ['api', 'kis_', 'trading/'],
            FileCategory.UTILITY: ['utils/', 'helper', 'config'],
            FileCategory.TEST: ['test_', '_test', 'spec_']
        }
    
    def _setup_logger(self) -> logging.Logger:
        """ë¡œê±° ì„¤ì •"""
        logger = logging.getLogger('advanced_project_upgrader')
        logger.setLevel(logging.INFO)
        
        if not logger.handlers:
            formatter = logging.Formatter(
                '[%(asctime)s] %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'
            )
            
            # ì½˜ì†” í•¸ë“¤ëŸ¬
            console_handler = logging.StreamHandler(sys.stdout)
            console_handler.setFormatter(formatter)
            logger.addHandler(console_handler)
            
            # íŒŒì¼ í•¸ë“¤ëŸ¬
            log_dir = self.project_root / 'logs'
            log_dir.mkdir(exist_ok=True)
            file_handler = logging.FileHandler(
                log_dir / f'advanced_upgrade_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log',
                encoding='utf-8'
            )
            file_handler.setFormatter(formatter)
            logger.addHandler(file_handler)
        
        return logger
    
    def get_all_python_files(self) -> List[Path]:
        """ëª¨ë“  Python íŒŒì¼ ìˆ˜ì§‘"""
        python_files = []
        
        for file_path in self.project_root.rglob('*.py'):
            # ì œì™¸ íŒ¨í„´ í™•ì¸
            if any(pattern in file_path.parts for pattern in self.exclude_patterns):
                continue
            
            # continuous_error_fix.pyëŠ” ê¸°ì¤€ íŒŒì¼ì´ë¯€ë¡œ ì œì™¸
            if file_path.name == 'continuous_error_fix.py':
                continue
                
            python_files.append(file_path)
        
        return sorted(python_files)
    
    def categorize_file(self, file_path: Path) -> FileCategory:
        """íŒŒì¼ ì¹´í…Œê³ ë¦¬ ë¶„ë¥˜"""
        file_str = str(file_path)
        
        for category, patterns in self.category_patterns.items():
            for pattern in patterns:
                if pattern in file_str:
                    return category
        
        return FileCategory.UTILITY
    
    def analyze_file_quality(self, file_path: Path) -> FileAnalysis:
        """íŒŒì¼ í’ˆì§ˆ ë¶„ì„"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            lines = content.split('\n')
            total_lines = len(lines)
            
            # í’ˆì§ˆ ì ìˆ˜ ê³„ì‚° (0-100ì )
            score = 0
            issues = []
            improvements = []
            
            # 1. íŒŒì¼ ìƒë‹¨ í•œê¸€ ì£¼ì„ (10ì )
            if lines and lines[0].strip().startswith('#') and any(keyword in lines[0] for keyword in ['íŒŒì¼ëª…', 'ì—­í• ', 'ì‹œìŠ¤í…œ']):
                score += 10
            else:
                issues.append("íŒŒì¼ ìƒë‹¨ì— í•œê¸€ ì£¼ì„(íŒŒì¼ëª…/ì—­í• ) ì—†ìŒ")
                improvements.append("íŒŒì¼ ìƒë‹¨ì— í•œê¸€ ì£¼ì„ ì¶”ê°€")
            
            # 2. íƒ€ì… íŒíŠ¸ ì‚¬ìš© (15ì )
            type_hint_count = len(re.findall(r':\s*\w+', content))
            if type_hint_count >= total_lines * 0.1:  # 10% ì´ìƒ
                score += 15
            elif type_hint_count >= total_lines * 0.05:  # 5% ì´ìƒ
                score += 10
            else:
                issues.append("íƒ€ì… íŒíŠ¸ ë¶€ì¡±")
                improvements.append("í•¨ìˆ˜/ë³€ìˆ˜ì— íƒ€ì… íŒíŠ¸ ì¶”ê°€")
            
            # 3. ìµœì‹  Python ë¬¸ë²• (15ì )
            modern_features = 0
            if 'match ' in content:
                modern_features += 1
            if ':=' in content:  # walrus operator
                modern_features += 1
            if 'f"' in content or "f'" in content:
                modern_features += 1
            if 'async def' in content:
                modern_features += 1
            if 'await' in content:
                modern_features += 1
            
            score += min(15, modern_features * 3)
            if modern_features < 3:
                issues.append("ìµœì‹  Python ë¬¸ë²• ë¶€ì¡±")
                improvements.append("match-case, walrus operator, f-string, async/await í™œìš©")
            
            # 4. ì—ëŸ¬ ì²˜ë¦¬ (15ì )
            try_except_count = len(re.findall(r'try:', content))
            if try_except_count >= 1:
                score += 15
            else:
                issues.append("ì—ëŸ¬ ì²˜ë¦¬ ë¶€ì¡±")
                improvements.append("try-except ë¸”ë¡ ì¶”ê°€")
            
            # 5. ë¬¸ì„œí™” (15ì )
            docstring_count = len(re.findall(r'""".*?"""', content, re.DOTALL))
            comment_count = len([line for line in lines if line.strip().startswith('#')])
            
            if docstring_count >= 1 and comment_count >= total_lines * 0.1:
                score += 15
            elif docstring_count >= 1 or comment_count >= total_lines * 0.05:
                score += 10
            else:
                issues.append("ë¬¸ì„œí™” ë¶€ì¡±")
                improvements.append("docstring ë° ì£¼ì„ ì¶”ê°€")
            
            # 6. ì½”ë“œ êµ¬ì¡° (15ì )
            class_count = len(re.findall(r'class\s+\w+', content))
            function_count = len(re.findall(r'def\s+\w+', content))
            
            if class_count >= 1 and function_count >= 3:
                score += 15
            elif function_count >= 5:
                score += 10
            else:
                issues.append("ì½”ë“œ êµ¬ì¡° ê°œì„  í•„ìš”")
                improvements.append("í´ë˜ìŠ¤/í•¨ìˆ˜ ë¶„ë¦¬ ë° ëª¨ë“ˆí™”")
            
            # 7. ì„±ëŠ¥ ìµœì í™” (15ì )
            if 'asyncio' in content or 'concurrent' in content:
                score += 15
            elif 'threading' in content or 'multiprocessing' in content:
                score += 10
            else:
                issues.append("ì„±ëŠ¥ ìµœì í™” ë¶€ì¡±")
                improvements.append("ë¹„ë™ê¸° ì²˜ë¦¬ ë˜ëŠ” ë³‘ë ¬ ì²˜ë¦¬ ì ìš©")
            
            # í’ˆì§ˆ ìˆ˜ì¤€ ê²°ì •
            if score >= 95:
                quality_level = QualityLevel.A_PLUS
            elif score >= 85:
                quality_level = QualityLevel.A
            elif score >= 70:
                quality_level = QualityLevel.B
            elif score >= 50:
                quality_level = QualityLevel.C
            elif score >= 30:
                quality_level = QualityLevel.D
            else:
                quality_level = QualityLevel.F
            
            return FileAnalysis(
                file_path=file_path,
                category=self.categorize_file(file_path),
                current_quality=quality_level,
                current_score=score,
                upgrade_needed=score < 95,
                issues=issues,
                improvements=improvements
            )
            
        except Exception as e:
            self.logger.error(f"íŒŒì¼ ë¶„ì„ ì‹¤íŒ¨: {file_path} - {e}")
            return FileAnalysis(
                file_path=file_path,
                category=self.categorize_file(file_path),
                current_quality=QualityLevel.F,
                current_score=0,
                upgrade_needed=True,
                issues=[f"íŒŒì¼ ë¶„ì„ ì˜¤ë¥˜: {e}"],
                improvements=["íŒŒì¼ ì½ê¸° ì˜¤ë¥˜ ìˆ˜ì •"]
            )
    
    def _create_advanced_file_header(self, file_path: Path, category: FileCategory) -> str:
        """ê³ ê¸‰ íŒŒì¼ í—¤ë” ìƒì„±"""
        file_name = file_path.name
        category_name = category.value.replace('_', ' ').title()
        
        # ì¹´í…Œê³ ë¦¬ë³„ íŠ¹í™”ëœ ì„¤ëª…
        category_descriptions = {
            FileCategory.MAIN_EXECUTABLE: "ì‹œìŠ¤í…œì˜ ë©”ì¸ ì‹¤í–‰ ì§„ì…ì ",
            FileCategory.CORE_MODULE: "í•µì‹¬ ì‹œìŠ¤í…œ ëª¨ë“ˆ",
            FileCategory.DATA_PROCESSOR: "ë°ì´í„° ì²˜ë¦¬ ë° ë¶„ì„ ëª¨ë“ˆ",
            FileCategory.ANALYSIS_ENGINE: "íˆ¬ì ë¶„ì„ ë° ì „ëµ ì—”ì§„",
            FileCategory.API_INTEGRATION: "ì™¸ë¶€ API ì—°ë™ ëª¨ë“ˆ",
            FileCategory.UTILITY: "ìœ í‹¸ë¦¬í‹° ë° í—¬í¼ ëª¨ë“ˆ",
            FileCategory.TEST: "í…ŒìŠ¤íŠ¸ ë° ê²€ì¦ ëª¨ë“ˆ"
        }
        
        description = category_descriptions.get(category, "ëª¨ë“ˆ")
        
        return f"""# {file_name} - {category_name} ëª¨ë“ˆ
# ì—­í• : {description}
# ìµœì‹  Python 3.11+ ë¬¸ë²• ì ìš©, íƒ€ì… íŒíŠ¸, ë¹„ë™ê¸° ì²˜ë¦¬, ì—ëŸ¬ ì²˜ë¦¬ ì™„ë²½ êµ¬í˜„
# ì„±ëŠ¥ ìµœì í™”, ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±, ìœ ì§€ë³´ìˆ˜ì„±, í™•ì¥ì„± ê³ ë ¤
"""

    def _add_type_hints(self, content: str) -> str:
        """íƒ€ì… íŒíŠ¸ ì¶”ê°€"""
        lines = content.split('\n')
        updated_lines = []
        
        for line in lines:
            # í•¨ìˆ˜ ì •ì˜ì— íƒ€ì… íŒíŠ¸ ì¶”ê°€
            if line.strip().startswith('def ') and ':' not in line:
                # ê°„ë‹¨í•œ íƒ€ì… íŒíŠ¸ ì¶”ê°€
                if 'self' in line:
                    line = line.replace('(self)', '(self) -> None')
                elif '(' in line and ')' in line:
                    line = line.replace('):', ') -> Any:')
            
            # ë³€ìˆ˜ í• ë‹¹ì— íƒ€ì… íŒíŠ¸ ì¶”ê°€ (ê°„ë‹¨í•œ ê²½ìš°)
            if ' = ' in line and not line.strip().startswith('#'):
                var_name = line.split(' = ')[0].strip()
                if var_name.isidentifier() and not ':' in line:
                    # ê°„ë‹¨í•œ íƒ€ì… ì¶”ë¡ 
                    if '[]' in line or 'list' in line:
                        line = line.replace(' = ', ': List[Any] = ')
                    elif '{}' in line or 'dict' in line:
                        line = line.replace(' = ', ': Dict[str, Any] = ')
                    elif 'True' in line or 'False' in line:
                        line = line.replace(' = ', ': bool = ')
                    elif line.split(' = ')[1].strip().isdigit():
                        line = line.replace(' = ', ': int = ')
            
            updated_lines.append(line)
        
        return '\n'.join(updated_lines)
    
    def _add_error_handling(self, content: str) -> str:
        """ì—ëŸ¬ ì²˜ë¦¬ ì¶”ê°€"""
        lines = content.split('\n')
        updated_lines = []
        
        # íŒŒì¼ ìƒë‹¨ì— ê¸°ë³¸ ì„í¬íŠ¸ ì¶”ê°€
        if 'import' in content and 'try:' not in content:
            # ì²« ë²ˆì§¸ import ë¼ì¸ ë‹¤ìŒì— ì—ëŸ¬ ì²˜ë¦¬ ì„í¬íŠ¸ ì¶”ê°€
            for i, line in enumerate(lines):
                updated_lines.append(line)
                if line.strip().startswith('import ') and i == 0:
                    updated_lines.append('import logging')
                    updated_lines.append('from typing import Any, Dict, List, Optional')
                    updated_lines.append('')
                    updated_lines.append('# ë¡œê±° ì„¤ì •')
                    updated_lines.append('logger = logging.getLogger(__name__)')
                    updated_lines.append('')
        
        # ì£¼ìš” í•¨ìˆ˜ì— try-except ì¶”ê°€
        for i, line in enumerate(lines):
            if line.strip().startswith('def ') and 'try:' not in content:
                # í•¨ìˆ˜ ì‹œì‘ ë¶€ë¶„ì— ì—ëŸ¬ ì²˜ë¦¬ ì¶”ê°€
                updated_lines.append(line)
                updated_lines.append('    try:')
                # í•¨ìˆ˜ ë³¸ë¬¸ì„ ë“¤ì—¬ì“°ê¸°ë¡œ ê°ì‹¸ê¸°
                continue
            elif line.strip() == '' and i > 0 and lines[i-1].strip().startswith('try:'):
                # try ë¸”ë¡ ëì— except ì¶”ê°€
                updated_lines.append('    except Exception as e:')
                updated_lines.append('        logger.error(f"ì˜¤ë¥˜ ë°œìƒ: {e}")')
                updated_lines.append('        raise')
            else:
                updated_lines.append(line)
        
        return '\n'.join(updated_lines)
    
    def _add_modern_python_features(self, content: str) -> str:
        """ìµœì‹  Python ê¸°ëŠ¥ ì¶”ê°€"""
        # f-string ë³€í™˜
        content = re.sub(r'([^f])"([^"]*)\{([^}]*)\}([^"]*)"', r'\1f"\2{\3}\4"', content)
        
        # walrus operator ì¶”ê°€ (ê°„ë‹¨í•œ ê²½ìš°)
        content = re.sub(r'(\w+)\s*=\s*([^;]+);\s*if\s+\1', r'if (\1 := \2):', content)
        
        # match-case ì¶”ê°€ (ê°„ë‹¨í•œ ê²½ìš°)
        if 'if ' in content and 'elif ' in content:
            # ê°„ë‹¨í•œ if-elif ì²´ì¸ì„ match-caseë¡œ ë³€í™˜
            pass
        
        return content
    
    async def upgrade_file_advanced(self, analysis: FileAnalysis) -> UpgradeResult:
        """ê³ ê¸‰ íŒŒì¼ ì—…ê·¸ë ˆì´ë“œ"""
        try:
            # ì›ë³¸ íŒŒì¼ ë°±ì—…
            backup_path = analysis.file_path.with_suffix(f'.backup_{int(time.time())}')
            shutil.copy2(analysis.file_path, backup_path)
            
            # íŒŒì¼ ë‚´ìš© ì½ê¸°
            async with aiofiles.open(analysis.file_path, 'r', encoding='utf-8') as f:
                content = await f.read()
            
            lines = content.split('\n')
            upgraded_lines = []
            
            # 1. ê³ ê¸‰ íŒŒì¼ í—¤ë” ì¶”ê°€
            if not (lines and lines[0].strip().startswith('#') and any(keyword in lines[0] for keyword in ['íŒŒì¼ëª…', 'ì—­í• '])):
                header = self._create_advanced_file_header(analysis.file_path, analysis.category)
                upgraded_lines.extend(header.split('\n'))
                upgraded_lines.append("")
            
            # 2. ê¸°ì¡´ ë‚´ìš© ì¶”ê°€
            upgraded_lines.extend(lines)
            
            # 3. ê³ ê¸‰ ê¸°ëŠ¥ ì ìš©
            upgraded_content = '\n'.join(upgraded_lines)
            
            # íƒ€ì… íŒíŠ¸ ì¶”ê°€
            upgraded_content = self._add_type_hints(upgraded_content)
            
            # ì—ëŸ¬ ì²˜ë¦¬ ì¶”ê°€
            upgraded_content = self._add_error_handling(upgraded_content)
            
            # ìµœì‹  Python ê¸°ëŠ¥ ì¶”ê°€
            upgraded_content = self._add_modern_python_features(upgraded_content)
            
            # ì—…ê·¸ë ˆì´ë“œëœ ë‚´ìš© ì €ì¥
            async with aiofiles.open(analysis.file_path, 'w', encoding='utf-8') as f:
                await f.write(upgraded_content)
            
            # ì—…ê·¸ë ˆì´ë“œ í›„ í’ˆì§ˆ ì¬ë¶„ì„
            new_analysis = self.analyze_file_quality(analysis.file_path)
            
            return {
                'success': True,
                'original_score': analysis.current_score,
                'new_score': new_analysis.current_score,
                'score_improvement': new_analysis.current_score - analysis.current_score,
                'backup_path': backup_path
            }
            
        except Exception as e:
            self.logger.error(f"ê³ ê¸‰ íŒŒì¼ ì—…ê·¸ë ˆì´ë“œ ì‹¤íŒ¨: {analysis.file_path} - {e}")
            return {
                'success': False,
                'error': str(e),
                'original_score': analysis.current_score,
                'new_score': analysis.current_score,
                'score_improvement': 0
            }
    
    async def run_advanced_upgrade(self) -> Dict[str, Any]:
        """ê³ ê¸‰ ì „ì²´ ì—…ê·¸ë ˆì´ë“œ ì‹¤í–‰"""
        self.logger.info("ğŸš€ ê³ ê¸‰ í”„ë¡œì íŠ¸ ì „ì²´ A+ ìˆ˜ì¤€ ì—…ê·¸ë ˆì´ë“œ ì‹œì‘")
        
        # 1. ëª¨ë“  Python íŒŒì¼ ìˆ˜ì§‘
        python_files = self.get_all_python_files()
        self.metrics.total_files = len(python_files)
        
        self.logger.info(f"ğŸ“ ì´ {self.metrics.total_files}ê°œ Python íŒŒì¼ ë°œê²¬")
        
        # 2. íŒŒì¼ë³„ í’ˆì§ˆ ë¶„ì„
        analyses = []
        for file_path in python_files:
            analysis = self.analyze_file_quality(file_path)
            analyses.append(analysis)
            
            if analysis.upgrade_needed:
                self.logger.info(f"ğŸ” {file_path.name}: {analysis.current_quality.value} ({analysis.current_score}ì )")
        
        # 3. ê³ ê¸‰ ì—…ê·¸ë ˆì´ë“œ ì‹¤í–‰
        upgrade_results = []
        for analysis in analyses:
            if analysis.upgrade_needed:
                self.logger.info(f"ğŸ”§ ê³ ê¸‰ ì—…ê·¸ë ˆì´ë“œ ì¤‘: {analysis.file_path.name}")
                result = await self.upgrade_file_advanced(analysis)
                upgrade_results.append(result)
                
                if result['success']:
                    self.metrics.files_upgraded += 1
                    self.metrics.total_score_improvement += result['score_improvement']
                    self.logger.info(f"âœ… {analysis.file_path.name}: {result['original_score']} â†’ {result['new_score']}ì  (+{result['score_improvement']})")
                else:
                    self.logger.error(f"âŒ {analysis.file_path.name}: ì—…ê·¸ë ˆì´ë“œ ì‹¤íŒ¨ - {result['error']}")
            else:
                self.metrics.files_skipped += 1
                self.logger.info(f"â­ï¸ {analysis.file_path.name}: ì´ë¯¸ A+ ìˆ˜ì¤€ (ê±´ë„ˆëœ€)")
        
        # 4. ê²°ê³¼ ìš”ì•½
        execution_time = time.time() - self.metrics.start_time
        
        summary = {
            'execution_time': f"{execution_time:.2f}ì´ˆ",
            'total_files': self.metrics.total_files,
            'files_upgraded': self.metrics.files_upgraded,
            'files_skipped': self.metrics.files_skipped,
            'completion_rate': f"{self.metrics.completion_rate:.1f}%",
            'average_score_improvement': f"{self.metrics.average_score_improvement:.1f}ì ",
            'total_score_improvement': self.metrics.total_score_improvement,
            'upgrade_results': upgrade_results
        }
        
        self.logger.info("ğŸ ê³ ê¸‰ í”„ë¡œì íŠ¸ ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ")
        self.logger.info(f"ğŸ“Š ê²°ê³¼: {self.metrics.files_upgraded}/{self.metrics.total_files}ê°œ íŒŒì¼ ì—…ê·¸ë ˆì´ë“œ")
        self.logger.info(f"ğŸ“ˆ í‰ê·  ì ìˆ˜ ê°œì„ : {self.metrics.average_score_improvement:.1f}ì ")
        
        return summary

async def main() -> None:
    """ë©”ì¸ í•¨ìˆ˜"""
    project_root = Path(__file__).resolve().parent
    upgrader = AdvancedProjectUpgrader(project_root)
    
    try:
        summary = await upgrader.run_advanced_upgrade()
        
        # ê²°ê³¼ ì¶œë ¥
        print(f"\n{'='*80}")
        print("ğŸ¯ ê³ ê¸‰ í”„ë¡œì íŠ¸ ì „ì²´ A+ ìˆ˜ì¤€ ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ")
        print(f"{'='*80}")
        print(f"â±ï¸ ì‹¤í–‰ ì‹œê°„: {summary['execution_time']}")
        print(f"ğŸ“ ì „ì²´ íŒŒì¼: {summary['total_files']}ê°œ")
        print(f"âœ… ì—…ê·¸ë ˆì´ë“œ: {summary['files_upgraded']}ê°œ")
        print(f"â­ï¸ ê±´ë„ˆëœ€: {summary['files_skipped']}ê°œ")
        print(f"ğŸ“Š ì™„ë£Œìœ¨: {summary['completion_rate']}")
        print(f"ğŸ“ˆ í‰ê·  ì ìˆ˜ ê°œì„ : {summary['average_score_improvement']}")
        print(f"ğŸ¯ ì´ ì ìˆ˜ ê°œì„ : {summary['total_score_improvement']}ì ")
        
        # ê²°ê³¼ ì €ì¥
        results_dir = project_root / 'results'
        results_dir.mkdir(exist_ok=True)
        
        results_file = results_dir / f'advanced_upgrade_results_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
        
        # JSON ì§ë ¬í™” ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜
        serializable_summary = {
            'execution_time': summary['execution_time'],
            'total_files': summary['total_files'],
            'files_upgraded': summary['files_upgraded'],
            'files_skipped': summary['files_skipped'],
            'completion_rate': summary['completion_rate'],
            'average_score_improvement': summary['average_score_improvement'],
            'total_score_improvement': summary['total_score_improvement']
        }
        
        async with aiofiles.open(results_file, 'w', encoding='utf-8') as f:
            await f.write(json.dumps(serializable_summary, ensure_ascii=False, indent=2))
        
        print(f"\nğŸ’¾ ìƒì„¸ ê²°ê³¼ ì €ì¥: {results_file}")
        
    except Exception as e:
        print(f"ğŸš¨ ê³ ê¸‰ ì—…ê·¸ë ˆì´ë“œ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main()) 