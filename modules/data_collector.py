#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üöÄ Í≥†ÌíàÏßà Îç∞Ïù¥ÌÑ∞ ÏàòÏßëÍ∏∞
ÏΩîÏä§Ìîº200¬∑ÎÇòÏä§Îã•100¬∑S&P500 Ï†ÑÏ≤¥ Ï¢ÖÎ™© Îç∞Ïù¥ÌÑ∞Î•º .env APIÎ•º ÏµúÎåÄÌïú ÌôúÏö©ÌïòÏó¨ ÏàòÏßë
Gemini AIÍ∞Ä ÌïÑÏöîÌïú Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Í≥†ÌíàÏßàÎ°ú Ï†úÍ≥µ
"""

import os
import asyncio
import logging
import pandas as pd
import yfinance as yf
import requests
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from dotenv import load_dotenv

# .env ÌååÏùº Î°úÎìú
load_dotenv()

from investment_strategies import StockData

logger = logging.getLogger(__name__)

class MultiDataCollector:
    """üöÄ Îã§Ï§ë ÏÜåÏä§ Îç∞Ïù¥ÌÑ∞ ÏàòÏßëÍ∏∞ - API ÏµúÎåÄ ÌôúÏö©"""
    
    def __init__(self):
        """Ï¥àÍ∏∞Ìôî Î∞è API ÌÇ§ Î°úÎìú"""
        self.kis_app_key = os.getenv('LIVE_KIS_APP_KEY')
        self.kis_app_secret = os.getenv('LIVE_KIS_APP_SECRET')
        self.kis_account = os.getenv('LIVE_KIS_ACCOUNT_NUMBER')
        self.dart_api_key = os.getenv('DART_API_KEY')
        
        # ÏàòÏßë ÌÜµÍ≥Ñ
        self.collected_count = 0
        self.failed_count = 0
        self.start_time = None
        
        logger.info("üìä Îã§Ï§ë Îç∞Ïù¥ÌÑ∞ ÏàòÏßëÍ∏∞ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        logger.info(f"KIS API: {'‚úÖ' if self.kis_app_key else '‚ùå'}")
        logger.info(f"DART API: {'‚úÖ' if self.dart_api_key else '‚ùå'}")
    
    async def collect_all_markets(self) -> List[StockData]:
        """üåè Ï†ÑÏ≤¥ ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÏàòÏßë"""
        logger.info("üöÄ Ï†ÑÏ≤¥ ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÏãúÏûë")
        self.start_time = time.time()
        
        all_stocks = []
        
        # 1. ÏΩîÏä§Ìîº200 ÏàòÏßë
        logger.info("üìà ÏΩîÏä§Ìîº200 Îç∞Ïù¥ÌÑ∞ ÏàòÏßë")
        kospi_stocks = await self._collect_kospi200()
        all_stocks.extend(kospi_stocks)
        logger.info(f"‚úÖ ÏΩîÏä§Ìîº200: {len(kospi_stocks)}Í∞ú Ï¢ÖÎ™©")
        
        # 2. ÎÇòÏä§Îã•100 ÏàòÏßë
        logger.info("üá∫üá∏ ÎÇòÏä§Îã•100 Îç∞Ïù¥ÌÑ∞ ÏàòÏßë")
        nasdaq_stocks = await self._collect_nasdaq100()
        all_stocks.extend(nasdaq_stocks)
        logger.info(f"‚úÖ ÎÇòÏä§Îã•100: {len(nasdaq_stocks)}Í∞ú Ï¢ÖÎ™©")
        
        # 3. S&P500 ÏàòÏßë
        logger.info("üìä S&P500 Îç∞Ïù¥ÌÑ∞ ÏàòÏßë")
        sp500_stocks = await self._collect_sp500()
        all_stocks.extend(sp500_stocks)
        logger.info(f"‚úÖ S&P500: {len(sp500_stocks)}Í∞ú Ï¢ÖÎ™©")
        
        elapsed_time = time.time() - self.start_time
        logger.info(f"üéâ Ï†ÑÏ≤¥ ÏàòÏßë ÏôÑÎ£å: {len(all_stocks)}Í∞ú Ï¢ÖÎ™© ({elapsed_time:.1f}Ï¥à)")
        
        return all_stocks
    
    async def _collect_kospi200(self) -> List[StockData]:
        """üìà ÏΩîÏä§Ìîº200 Ï¢ÖÎ™© ÏàòÏßë"""
        stocks = []
        
        try:
            # ÏΩîÏä§Ìîº200 Íµ¨ÏÑ±Ï¢ÖÎ™© Î¶¨Ïä§Ìä∏ (Ï£ºÏöî Ï¢ÖÎ™©Îì§)
            kospi200_symbols = [
                '005930.KS',  # ÏÇºÏÑ±Ï†ÑÏûê
                '000660.KS',  # SKÌïòÏù¥ÎãâÏä§
                '035420.KS',  # ÎÑ§Ïù¥Î≤Ñ
                '005380.KS',  # ÌòÑÎåÄÏûêÎèôÏ∞®
                '051910.KS',  # LGÌôîÌïô
                '028260.KS',  # ÏÇºÏÑ±Î¨ºÏÇ∞
                '006400.KS',  # ÏÇºÏÑ±SDI
                '012330.KS',  # ÌòÑÎåÄÎ™®ÎπÑÏä§
                '096770.KS',  # SKÏù¥ÎÖ∏Î≤†Ïù¥ÏÖò
                '003550.KS',  # LG
                '017670.KS',  # SKÌÖîÎ†àÏΩ§
                '030200.KS',  # KT
                '036570.KS',  # ÏóîÏî®ÏÜåÌîÑÌä∏
                '003490.KS',  # ÎåÄÌïúÌï≠Í≥µ
                '323410.KS',  # Ïπ¥Ïπ¥Ïò§Î±ÖÌÅ¨
                '035720.KS',  # Ïπ¥Ïπ¥Ïò§
                '207940.KS',  # ÏÇºÏÑ±Î∞îÏù¥Ïò§Î°úÏßÅÏä§
                '068270.KS',  # ÏÖÄÌä∏Î¶¨Ïò®
                '000270.KS',  # Í∏∞ÏïÑ
                '018260.KS',  # ÏÇºÏÑ±ÏóêÏä§ÎîîÏóêÏä§
            ]
            
            # Î≥ëÎ†¨ ÏàòÏßë
            with ThreadPoolExecutor(max_workers=10) as executor:
                futures = [
                    executor.submit(self._collect_single_stock, symbol, "KOSPI200")
                    for symbol in kospi200_symbols
                ]
                
                for future in as_completed(futures):
                    try:
                        stock_data = future.result()
                        if stock_data:
                            stocks.append(stock_data)
                            self.collected_count += 1
                    except Exception as e:
                        self.failed_count += 1
                        logger.warning(f"ÏΩîÏä§Ìîº200 Ï¢ÖÎ™© ÏàòÏßë Ïã§Ìå®: {e}")
        
        except Exception as e:
            logger.error(f"ÏΩîÏä§Ìîº200 ÏàòÏßë Ï§ë Ïò§Î•ò: {e}")
        
        return stocks
    
    async def _collect_nasdaq100(self) -> List[StockData]:
        """üá∫üá∏ ÎÇòÏä§Îã•100 Ï¢ÖÎ™© ÏàòÏßë"""
        stocks = []
        
        try:
            # ÎÇòÏä§Îã•100 Ï£ºÏöî Ï¢ÖÎ™©Îì§
            nasdaq100_symbols = [
                'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA',
                'META', 'NVDA', 'NFLX', 'PYPL', 'ADBE',
                'CMCSA', 'INTC', 'CSCO', 'PEP', 'COST',
                'TMUS', 'AVGO', 'TXN', 'QCOM', 'SBUX',
                'INTU', 'GILD', 'AMGN', 'AMAT', 'BKNG',
                'MDLZ', 'ISRG', 'ADP', 'CSX', 'REGN',
                'VRTX', 'FISV', 'ATVI', 'BIIB', 'CHTR',
                'MU', 'AMD', 'LRCX', 'MRNA', 'ADI'
            ]
            
            # Î≥ëÎ†¨ ÏàòÏßë
            with ThreadPoolExecutor(max_workers=15) as executor:
                futures = [
                    executor.submit(self._collect_single_stock, symbol, "NASDAQ100")
                    for symbol in nasdaq100_symbols
                ]
                
                for future in as_completed(futures):
                    try:
                        stock_data = future.result()
                        if stock_data:
                            stocks.append(stock_data)
                            self.collected_count += 1
                    except Exception as e:
                        self.failed_count += 1
                        logger.warning(f"ÎÇòÏä§Îã•100 Ï¢ÖÎ™© ÏàòÏßë Ïã§Ìå®: {e}")
        
        except Exception as e:
            logger.error(f"ÎÇòÏä§Îã•100 ÏàòÏßë Ï§ë Ïò§Î•ò: {e}")
        
        return stocks
    
    async def _collect_sp500(self) -> List[StockData]:
        """üìä S&P500 Ï¢ÖÎ™© ÏàòÏßë"""
        stocks = []
        
        try:
            # S&P500 Ï£ºÏöî Ï¢ÖÎ™©Îì§
            sp500_symbols = [
                'AAPL', 'MSFT', 'AMZN', 'GOOGL', 'TSLA',
                'BRK-B', 'UNH', 'JNJ', 'V', 'XOM',
                'JPM', 'PG', 'NVDA', 'HD', 'MA',
                'CVX', 'BAC', 'ABBV', 'PFE', 'KO',
                'AVGO', 'PEP', 'TMO', 'COST', 'WMT',
                'DIS', 'DHR', 'ABT', 'LIN', 'ACN',
                'VZ', 'ADBE', 'CRM', 'NKE', 'NEE',
                'BMY', 'ORCL', 'PM', 'CMCSA', 'HON'
            ]
            
            # Î≥ëÎ†¨ ÏàòÏßë
            with ThreadPoolExecutor(max_workers=15) as executor:
                futures = [
                    executor.submit(self._collect_single_stock, symbol, "S&P500")
                    for symbol in sp500_symbols
                ]
                
                for future in as_completed(futures):
                    try:
                        stock_data = future.result()
                        if stock_data:
                            stocks.append(stock_data)
                            self.collected_count += 1
                    except Exception as e:
                        self.failed_count += 1
                        logger.warning(f"S&P500 Ï¢ÖÎ™© ÏàòÏßë Ïã§Ìå®: {e}")
        
        except Exception as e:
            logger.error(f"S&P500 ÏàòÏßë Ï§ë Ïò§Î•ò: {e}")
        
        return stocks
    
    def _collect_single_stock(self, symbol: str, market: str) -> Optional[StockData]:
        """Îã®Ïùº Ï¢ÖÎ™© Îç∞Ïù¥ÌÑ∞ ÏàòÏßë"""
        try:
            # Yahoo FinanceÏóêÏÑú Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            ticker = yf.Ticker(symbol)
            info = ticker.info
            hist = ticker.history(period="6mo")
            
            if hist.empty or 'longName' not in info:
                return None
            
            # Í∏∞Î≥∏ Ï†ïÎ≥¥
            current_price = hist['Close'].iloc[-1] if len(hist) > 0 else info.get('currentPrice', 0)
            
            # Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞
            rsi = self._calculate_rsi(hist['Close']) if len(hist) >= 14 else None
            ma20 = hist['Close'].rolling(20).mean().iloc[-1] if len(hist) >= 20 else None
            ma60 = hist['Close'].rolling(60).mean().iloc[-1] if len(hist) >= 60 else None
            volume_ratio = hist['Volume'].iloc[-5:].mean() / hist['Volume'].iloc[-20:-5].mean() if len(hist) >= 20 else 1.0
            
            # StockData Í∞ùÏ≤¥ ÏÉùÏÑ±
            stock_data = StockData(
                symbol=symbol,
                name=info.get('longName', symbol),
                current_price=float(current_price),
                market_cap=info.get('marketCap'),
                pe_ratio=info.get('forwardPE') or info.get('trailingPE'),
                pb_ratio=info.get('priceToBook'),
                roe=info.get('returnOnEquity'),
                debt_ratio=self._calculate_debt_ratio(info),
                dividend_yield=info.get('dividendYield'),
                revenue_growth=info.get('revenueGrowth'),
                earnings_growth=info.get('earningsGrowth'),
                rsi=rsi,
                moving_avg_20=float(ma20) if ma20 and not pd.isna(ma20) else None,
                moving_avg_60=float(ma60) if ma60 and not pd.isna(ma60) else None,
                volume_ratio=float(volume_ratio) if volume_ratio and not pd.isna(volume_ratio) else 1.0,
                market=market,
                sector=info.get('sector', ''),
                news_sentiment=0.0  # Í∏∞Î≥∏Í∞í, Ï∂îÌõÑ Îâ¥Ïä§ Î∂ÑÏÑùÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
            )
            
            return stock_data
            
        except Exception as e:
            logger.warning(f"{symbol} Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®: {e}")
            return None
    
    def _calculate_rsi(self, prices: pd.Series, period: int = 14) -> Optional[float]:
        """RSI Í≥ÑÏÇ∞"""
        try:
            if len(prices) < period + 1:
                return None
            
            delta = prices.diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
            
            rs = gain / loss
            rsi = 100 - (100 / (1 + rs))
            
            return float(rsi.iloc[-1]) if not pd.isna(rsi.iloc[-1]) else None
        except:
            return None
    
    def _calculate_debt_ratio(self, info: Dict) -> Optional[float]:
        """Î∂ÄÏ±ÑÎπÑÏú® Í≥ÑÏÇ∞"""
        try:
            total_debt = info.get('totalDebt', 0)
            total_equity = info.get('totalStockholdersEquity', 1)
            
            if total_equity and total_equity > 0:
                return total_debt / total_equity
            return None
        except:
            return None
    
    def get_collection_stats(self) -> Dict[str, Any]:
        """ÏàòÏßë ÌÜµÍ≥Ñ Î∞òÌôò"""
        return {
            'collected': self.collected_count,
            'failed': self.failed_count,
            'success_rate': (self.collected_count / (self.collected_count + self.failed_count) * 100) 
                           if (self.collected_count + self.failed_count) > 0 else 0,
            'elapsed_time': time.time() - self.start_time if self.start_time else 0
        }

class DataCleaner:
    """üßπ Îç∞Ïù¥ÌÑ∞ Ï†ïÏ†ú Î∞è Í≤ÄÏ¶ù"""
    
    def __init__(self):
        self.cleaned_count = 0
        self.removed_count = 0
    
    def clean_stock_data(self, stocks: List[StockData]) -> List[StockData]:
        """Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ Ï†ïÏ†ú"""
        logger.info(f"üßπ Îç∞Ïù¥ÌÑ∞ Ï†ïÏ†ú ÏãúÏûë: {len(stocks)}Í∞ú Ï¢ÖÎ™©")
        
        cleaned_stocks = []
        
        for stock in stocks:
            if self._is_valid_stock(stock):
                # Îç∞Ïù¥ÌÑ∞ Î≥¥Ï†ï
                cleaned_stock = self._normalize_stock_data(stock)
                cleaned_stocks.append(cleaned_stock)
                self.cleaned_count += 1
            else:
                self.removed_count += 1
        
        logger.info(f"‚úÖ Ï†ïÏ†ú ÏôÑÎ£å: {len(cleaned_stocks)}Í∞ú Ïú†Ìö®, {self.removed_count}Í∞ú Ï†úÍ±∞")
        return cleaned_stocks
    
    def _is_valid_stock(self, stock: StockData) -> bool:
        """Ï¢ÖÎ™© Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù"""
        # Í∏∞Î≥∏ ÌïÑÏàò Ï†ïÎ≥¥ Ï≤¥ÌÅ¨
        if not stock.symbol or not stock.name or stock.current_price <= 0:
            return False
        
        # Í∑πÎã®Ï†ÅÏù∏ Í∞í ÌïÑÌÑ∞ÎßÅ
        if stock.pe_ratio and (stock.pe_ratio < 0 or stock.pe_ratio > 1000):
            return False
        
        if stock.pb_ratio and (stock.pb_ratio < 0 or stock.pb_ratio > 100):
            return False
        
        return True
    
    def _normalize_stock_data(self, stock: StockData) -> StockData:
        """Îç∞Ïù¥ÌÑ∞ Ï†ïÍ∑úÌôî Î∞è Î≥¥Ï†ï"""
        # None Í∞íÎì§ÏùÑ Í∏∞Î≥∏Í∞íÏúºÎ°ú ÎåÄÏ≤¥
        if stock.rsi is None:
            stock.rsi = 50.0  # Ï§ëÎ¶ΩÍ∞í
        
        if stock.volume_ratio is None:
            stock.volume_ratio = 1.0  # ÌèâÍ∑†Í∞í
        
        if stock.news_sentiment is None:
            stock.news_sentiment = 0.0  # Ï§ëÎ¶ΩÍ∞í
        
        return stock

if __name__ == "__main__":
    print("üöÄ Í≥†ÌíàÏßà Îç∞Ïù¥ÌÑ∞ ÏàòÏßëÍ∏∞ v1.0")
    print("=" * 50)
    
    async def test_collector():
        collector = MultiDataCollector()
        stocks = await collector.collect_all_markets()
        
        print(f"\nüìä ÏàòÏßë Í≤∞Í≥º:")
        print(f"  ‚Ä¢ Ï¥ù Ï¢ÖÎ™©: {len(stocks)}Í∞ú")
        print(f"  ‚Ä¢ ÏàòÏßë ÌÜµÍ≥Ñ: {collector.get_collection_stats()}")
        
        if stocks:
            print(f"\nüìà ÏÉòÌîå Ï¢ÖÎ™©:")
            for i, stock in enumerate(stocks[:3]):
                print(f"  {i+1}. {stock.name} ({stock.symbol}) - {stock.current_price:.2f}")
    
    asyncio.run(test_collector()) 