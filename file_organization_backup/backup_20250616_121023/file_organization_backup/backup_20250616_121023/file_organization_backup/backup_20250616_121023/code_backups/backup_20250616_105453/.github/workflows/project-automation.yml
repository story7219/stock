name: 🎯 프로젝트 관리 자동화

on:
  issues:
    types: [opened, closed, labeled, assigned]
  pull_request:
    types: [opened, closed, merged, labeled, review_requested]
  project_card:
    types: [moved]

jobs:
  auto-project-management:
    name: 📋 자동 프로젝트 관리
    runs-on: ubuntu-latest
    steps:
    - name: 🎯 이슈 자동 분류 및 프로젝트 보드 추가
      if: github.event_name == 'issues' && github.event.action == 'opened'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const issue = context.payload.issue;
          const issueBody = issue.body || '';
          const issueTitle = issue.title.toLowerCase();
          
          // AI를 통한 이슈 자동 분류
          let labels = [];
          let priority = 'medium';
          let projectColumn = 'To Do';
          
          // 키워드 기반 자동 라벨링
          if (issueTitle.includes('bug') || issueTitle.includes('오류') || issueTitle.includes('에러')) {
            labels.push('bug');
            priority = 'high';
            projectColumn = 'Urgent';
          } else if (issueTitle.includes('feature') || issueTitle.includes('기능') || issueTitle.includes('추가')) {
            labels.push('enhancement');
            projectColumn = 'Feature Requests';
          } else if (issueTitle.includes('전략') || issueTitle.includes('strategy')) {
            labels.push('strategy');
            labels.push('trading');
            projectColumn = 'Strategy Development';
          } else if (issueTitle.includes('백테스트') || issueTitle.includes('backtest')) {
            labels.push('testing');
            labels.push('analysis');
            projectColumn = 'Testing & Analysis';
          }
          
          // 우선순위 라벨 추가
          labels.push(`priority-${priority}`);
          
          // 라벨 적용
          if (labels.length > 0) {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: labels
            });
          }
          
          // 프로젝트 보드에 자동 추가 (프로젝트 ID는 실제 값으로 변경 필요)
          try {
            const projects = await github.rest.projects.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            if (projects.data.length > 0) {
              const project = projects.data[0];
              const columns = await github.rest.projects.listColumns({
                project_id: project.id
              });
              
              const targetColumn = columns.data.find(col => 
                col.name.includes(projectColumn) || col.name === 'To do'
              );
              
              if (targetColumn) {
                await github.rest.projects.createCard({
                  column_id: targetColumn.id,
                  content_id: issue.id,
                  content_type: 'Issue'
                });
                
                console.log(`✅ 이슈 #${issue.number}를 ${targetColumn.name} 컬럼에 추가했습니다.`);
              }
            }
          } catch (error) {
            console.log(`⚠️ 프로젝트 보드 추가 실패: ${error.message}`);
          }
          
          // 자동 할당 (특정 라벨에 따라)
          if (labels.includes('bug')) {
            await github.rest.issues.addAssignees({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              assignees: [context.repo.owner] // 또는 특정 사용자
            });
          }

    - name: 🔄 PR 상태 자동 업데이트
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const pr = context.payload.pull_request;
          const action = context.payload.action;
          
          // PR 자동 라벨링
          const prTitle = pr.title.toLowerCase();
          const prBody = pr.body || '';
          let labels = [];
          
          if (prTitle.includes('fix') || prTitle.includes('수정')) {
            labels.push('bugfix');
          } else if (prTitle.includes('feat') || prTitle.includes('기능')) {
            labels.push('feature');
          } else if (prTitle.includes('refactor') || prTitle.includes('리팩토링')) {
            labels.push('refactoring');
          } else if (prTitle.includes('strategy') || prTitle.includes('전략')) {
            labels.push('strategy');
          }
          
          // 변경된 파일 기반 라벨링
          const files = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: pr.number
          });
          
          const changedFiles = files.data.map(f => f.filename);
          
          if (changedFiles.some(f => f.includes('strategies/'))) {
            labels.push('strategy-change');
          }
          if (changedFiles.some(f => f.includes('tests/'))) {
            labels.push('test-change');
          }
          if (changedFiles.some(f => f.includes('.github/workflows/'))) {
            labels.push('ci-cd');
          }
          
          // 라벨 적용
          if (labels.length > 0) {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: labels
            });
          }
          
          // PR 크기 분석 및 라벨링
          const totalChanges = files.data.reduce((sum, file) => sum + file.changes, 0);
          let sizeLabel = '';
          
          if (totalChanges < 50) {
            sizeLabel = 'size/small';
          } else if (totalChanges < 200) {
            sizeLabel = 'size/medium';
          } else {
            sizeLabel = 'size/large';
          }
          
          await github.rest.issues.addLabels({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: pr.number,
            labels: [sizeLabel]
          });
          
          // 대형 PR에 대한 경고 코멘트
          if (totalChanges > 500) {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: `⚠️ **대형 PR 감지** (${totalChanges} 변경사항)\n\n이 PR은 매우 큽니다. 더 작은 단위로 분할하는 것을 고려해보세요:\n- 리뷰 시간 단축\n- 버그 발견 용이성 향상\n- 충돌 위험 감소`
            });
          }

  auto-milestone-management:
    name: 🎯 마일스톤 자동 관리
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
    steps:
    - name: 📅 마일스톤 진행률 업데이트
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const pr = context.payload.pull_request;
          
          if (pr.milestone) {
            const milestone = await github.rest.issues.getMilestone({
              owner: context.repo.owner,
              repo: context.repo.repo,
              milestone_number: pr.milestone.number
            });
            
            const issues = await github.rest.issues.listForMilestone({
              owner: context.repo.owner,
              repo: context.repo.repo,
              milestone: pr.milestone.number,
              state: 'all'
            });
            
            const totalIssues = issues.data.length;
            const closedIssues = issues.data.filter(issue => issue.state === 'closed').length;
            const progress = Math.round((closedIssues / totalIssues) * 100);
            
            // 마일스톤 완료 시 자동 알림
            if (progress === 100) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `🎉 **마일스톤 완료!** \n\n"${milestone.data.title}" 마일스톤이 100% 완료되었습니다!\n\n📊 완료된 작업: ${closedIssues}/${totalIssues}`
              });
            }
          } 