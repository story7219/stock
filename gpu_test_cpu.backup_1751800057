```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CPU ê°•ì œ ë”¥ëŸ¬ë‹ í…ŒìŠ¤íŠ¸ (GPU í˜¸í™˜ì„± ë¬¸ì œ í•´ê²°)
"""
import torch
import torch.nn as nn
import torch.optim as optim
import time
import numpy as np

def test_cpu_deep_learning():
    """CPU ë”¥ëŸ¬ë‹ ì‹¤ì „ í…ŒìŠ¤íŠ¸"""
    print("ğŸš€ CPU ë”¥ëŸ¬ë‹ ì‹¤ì „ í…ŒìŠ¤íŠ¸ ì‹œì‘!")
    
    # CPU ê°•ì œ ì‚¬ìš©
    device = torch.device('cpu')
    print(f"ì‚¬ìš© ë””ë°”ì´ìŠ¤: {device}")
    
    # ì‹¤ì „ ë”¥ëŸ¬ë‹ ëª¨ë¸ ì •ì˜
    class DeepNeuralNetwork(nn.Module):
        def __init__(self, input_size: int = 100, hidden_size: int = 256):
            super().__init__()
            self.layers = nn.Sequential(
                nn.Linear(input_size, hidden_size),
                nn.ReLU(),
                nn.Dropout(0.3),
                nn.Linear(hidden_size, hidden_size // 2),
                nn.ReLU(),
                nn.Dropout(0.3),
                nn.Linear(hidden_size // 2, hidden_size // 4),
                nn.ReLU(),
                nn.Dropout(0.2),
                nn.Linear(hidden_size // 4, 1)
            )
        
        def forward(self, x: torch.Tensor) -> torch.Tensor:
            return self.layers(x)
    
    # ëª¨ë¸ ìƒì„±
    model = DeepNeuralNetwork().to(device)
    optimizer = optim.Adam(model.parameters(), lr=0.001)
    criterion = nn.MSELoss()
    
    print(f"ëª¨ë¸ ìƒì„± ì™„ë£Œ - ë””ë°”ì´ìŠ¤: {next(iter(model.parameters()), None).device if model.parameters() else 'None'}")  # None ì²˜ë¦¬ ì¶”ê°€
    
    # ì‹¤ì „ ë°ì´í„° ìƒì„±
    batch_size = 1000
    input_size = 100
    
    X = torch.randn(batch_size, input_size).to(device)
    y = torch.randn(batch_size, 1).to(device)
    
    print(f"ë°ì´í„° ìƒì„± ì™„ë£Œ - X: {X.shape}, y: {y.shape}")
    
    # ì‹¤ì „ í•™ìŠµ
    print("\nğŸ”¥ CPU ë”¥ëŸ¬ë‹ í•™ìŠµ ì‹œì‘!")
    start_time = time.time()
    
    model.train()
    for epoch in range(100):
        optimizer.zero_grad()
        outputs = model(X)
        loss = criterion(outputs, y)
        loss.backward()
        optimizer.step()
        
        if epoch % 20 == 0:
            print(f"Epoch {epoch:3d}, ì†ì‹¤: {loss.item():.6f}")
    
    training_time = time.time() - start_time
    print(f"\nâœ… í•™ìŠµ ì™„ë£Œ! ì‹œê°„: {training_time:.2f}ì´ˆ")
    
    # ì¶”ë¡  í…ŒìŠ¤íŠ¸
    print("\nğŸ§  ì¶”ë¡  í…ŒìŠ¤íŠ¸ ì‹œì‘!")
    model.eval()
    with torch.no_grad():
        test_X = torch.randn(100, input_size).to(device)
        predictions = model(test_X)
        print(f"ì¶”ë¡  ì™„ë£Œ - ì˜ˆì¸¡ê°’(ì²« 5ê°œ): {predictions[:5].cpu().numpy().flatten()}")
    
    print("\nğŸ‰ CPU ë”¥ëŸ¬ë‹ í…ŒìŠ¤íŠ¸ ì„±ê³µ!")

def test_lstm_cpu():
    # ... (LSTM í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€)
    pass

if __name__ == "__main__":
    try:
        test_cpu_deep_learning()
        test_lstm_cpu()
        print("\n" + "="*50)
        print("ğŸŠ ëª¨ë“  CPU í…ŒìŠ¤íŠ¸ ì„±ê³µ! ë”¥ëŸ¬ë‹ ì¤€ë¹„ ì™„ë£Œ!")
    except Exception as e:
        print(f"âŒ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
        import traceback
        traceback.print_exc()
```