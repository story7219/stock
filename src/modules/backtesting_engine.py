#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üìà Î∞±ÌÖåÏä§ÌåÖ ÏóîÏßÑ v2.0
Ìà¨Ïûê Ï†ÑÎûµ Î∞±ÌÖåÏä§Ìä∏ Î∞è ÏÑ±Í≥º Î∂ÑÏÑù
"""

import asyncio
import logging
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
import json
import sqlite3
from pathlib import Path
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
import warnings
warnings.filterwarnings('ignore')

logger = logging.getLogger(__name__)

@dataclass
class BacktestConfig:
    """Î∞±ÌÖåÏä§Ìä∏ ÏÑ§Ï†ï"""
    start_date: str
    end_date: str
    initial_capital: float = 10000000  # Ï¥àÍ∏∞ ÏûêÎ≥∏ 1Ï≤úÎßåÏõê
    commission: float = 0.0015  # ÏàòÏàòÎ£å 0.15%
    slippage: float = 0.001  # Ïä¨Î¶¨ÌîºÏßÄ 0.1%
    max_positions: int = 10  # ÏµúÎåÄ Î≥¥Ïú† Ï¢ÖÎ™© Ïàò
    rebalance_frequency: str = "weekly"  # daily, weekly, monthly
    benchmark: str = "^KS11"  # ÏΩîÏä§Ìîº ÏßÄÏàò

@dataclass
class Trade:
    """Í±∞Îûò Í∏∞Î°ù"""
    symbol: str
    entry_date: datetime
    exit_date: Optional[datetime]
    entry_price: float
    exit_price: Optional[float]
    quantity: int
    trade_type: str  # BUY, SELL
    strategy: str
    pnl: Optional[float] = None
    pnl_pct: Optional[float] = None

@dataclass
class PerformanceMetrics:
    """ÏÑ±Í≥º ÏßÄÌëú"""
    total_return: float
    annual_return: float
    volatility: float
    sharpe_ratio: float
    max_drawdown: float
    win_rate: float
    profit_factor: float
    total_trades: int
    avg_trade_return: float
    best_trade: float
    worst_trade: float
    calmar_ratio: float
    sortino_ratio: float
    beta: float
    alpha: float
    information_ratio: float

class BacktestingEngine:
    """Î∞±ÌÖåÏä§ÌåÖ ÏóîÏßÑ"""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Î∞±ÌÖåÏä§ÌåÖ ÏóîÏßÑ Ï¥àÍ∏∞Ìôî"""
        self.config = config or {
            'initial_capital': 1000000,
            'commission_rate': 0.001,
            'slippage_rate': 0.0005,
            'risk_free_rate': 0.02,
            'start_date': '2023-01-01',
            'end_date': '2024-01-01',
            'benchmark': 'SPY',
            'rebalance_frequency': 'monthly'
        }
        self.results = {}
        self.performance_metrics = {}
        logger.info("Î∞±ÌÖåÏä§ÌåÖ ÏóîÏßÑ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        self.trades: List[Trade] = []
        self.portfolio_value = []
        self.positions = {}  # symbol -> quantity
        self.cash = self.config['initial_capital']
        self.benchmark_data = None
        self.results_db = "data/backtest_results.db"
        self.initialize_database()
    
    def initialize_database(self):
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî"""
        Path("data").mkdir(exist_ok=True)
        conn = sqlite3.connect(self.results_db)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS backtest_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                strategy_name TEXT,
                start_date TEXT,
                end_date TEXT,
                total_return REAL,
                annual_return REAL,
                sharpe_ratio REAL,
                max_drawdown REAL,
                win_rate REAL,
                total_trades INTEGER,
                config TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS trade_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                backtest_id INTEGER,
                symbol TEXT,
                entry_date TEXT,
                exit_date TEXT,
                entry_price REAL,
                exit_price REAL,
                quantity INTEGER,
                pnl REAL,
                pnl_pct REAL,
                strategy TEXT,
                FOREIGN KEY (backtest_id) REFERENCES backtest_results (id)
            )
        ''')
        
        conn.commit()
        conn.close()
    
    async def run_backtest(self, strategy_func, symbols: List[str], strategy_name: str) -> Dict[str, Any]:
        """Î∞±ÌÖåÏä§Ìä∏ Ïã§Ìñâ"""
        try:
            logger.info(f"Î∞±ÌÖåÏä§Ìä∏ ÏãúÏûë: {strategy_name}")
            
            # Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            price_data = await self._collect_price_data(symbols)
            if price_data.empty:
                raise ValueError("Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞Î•º ÏàòÏßëÌï† Ïàò ÏóÜÏäµÎãàÎã§")
            
            # Î≤§ÏπòÎßàÌÅ¨ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            self.benchmark_data = await self._collect_benchmark_data()
            
            # Î∞±ÌÖåÏä§Ìä∏ Ïã§Ìñâ
            await self._execute_backtest(strategy_func, price_data, strategy_name)
            
            # ÏÑ±Í≥º Î∂ÑÏÑù
            performance = self._calculate_performance()
            
            # Í≤∞Í≥º Ï†ÄÏû•
            backtest_id = self._save_results(strategy_name, performance)
            
            # Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
            report = self._generate_report(performance, strategy_name)
            
            logger.info(f"Î∞±ÌÖåÏä§Ìä∏ ÏôÑÎ£å: {strategy_name}")
            return {
                "backtest_id": backtest_id,
                "performance": performance,
                "report": report,
                "trades": [asdict(trade) for trade in self.trades]
            }
            
        except Exception as e:
            logger.error(f"Î∞±ÌÖåÏä§Ìä∏ Ïã§Ìñâ Ïò§Î•ò: {e}")
            raise
    
    async def _collect_price_data(self, symbols: List[str]) -> pd.DataFrame:
        """Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ ÏàòÏßë"""
        try:
            data_frames = []
            
            for symbol in symbols:
                try:
                    ticker = yf.Ticker(symbol)
                    hist = ticker.history(
                        start=self.config['start_date'],
                        end=self.config['end_date'],
                        interval='1d'
                    )
                    
                    if not hist.empty:
                        hist['Symbol'] = symbol
                        data_frames.append(hist)
                        
                except Exception as e:
                    logger.warning(f"Ï¢ÖÎ™© {symbol} Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®: {e}")
                    continue
            
            if data_frames:
                combined_data = pd.concat(data_frames)
                combined_data.reset_index(inplace=True)
                return combined_data
            else:
                return pd.DataFrame()
                
        except Exception as e:
            logger.error(f"Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïò§Î•ò: {e}")
            return pd.DataFrame()
    
    async def _collect_benchmark_data(self) -> pd.DataFrame:
        """Î≤§ÏπòÎßàÌÅ¨ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë"""
        try:
            ticker = yf.Ticker(self.config['benchmark'])
            data = ticker.history(
                start=self.config['start_date'],
                end=self.config['end_date'],
                interval='1d'
            )
            return data
            
        except Exception as e:
            logger.error(f"Î≤§ÏπòÎßàÌÅ¨ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïò§Î•ò: {e}")
            return pd.DataFrame()
    
    async def _execute_backtest(self, strategy_func, price_data: pd.DataFrame, strategy_name: str):
        """Î∞±ÌÖåÏä§Ìä∏ Ïã§Ìñâ"""
        try:
            # ÎÇ†ÏßúÎ≥ÑÎ°ú Í∑∏Î£πÌôî
            grouped_data = price_data.groupby('Date')
            
            for date, day_data in grouped_data:
                # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í∞ÄÏπò Í≥ÑÏÇ∞
                portfolio_value = self._calculate_portfolio_value(day_data)
                self.portfolio_value.append({
                    'Date': date,
                    'Value': portfolio_value
                })
                
                # Ï†ÑÎûµ Ïã§Ìñâ
                signals = await strategy_func(day_data, self.positions)
                
                # Ïã†Ìò∏ Ï≤òÎ¶¨
                for signal in signals:
                    await self._process_signal(signal, day_data, strategy_name)
                
                # Î¶¨Î∞∏Îü∞Ïã± Ï≤¥ÌÅ¨
                if self._should_rebalance(date):
                    await self._rebalance_portfolio(day_data)
                    
        except Exception as e:
            logger.error(f"Î∞±ÌÖåÏä§Ìä∏ Ïã§Ìñâ Ï§ë Ïò§Î•ò: {e}")
            raise
    
    def _calculate_portfolio_value(self, day_data: pd.DataFrame) -> float:
        """Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í∞ÄÏπò Í≥ÑÏÇ∞"""
        total_value = self.cash
        
        for symbol, quantity in self.positions.items():
            symbol_data = day_data[day_data['Symbol'] == symbol]
            if not symbol_data.empty:
                current_price = symbol_data['Close'].iloc[0]
                total_value += quantity * current_price
        
        return total_value
    
    async def _process_signal(self, signal: Dict[str, Any], day_data: pd.DataFrame, strategy_name: str):
        """Îß§Îß§ Ïã†Ìò∏ Ï≤òÎ¶¨"""
        try:
            symbol = signal['symbol']
            action = signal['action']  # BUY, SELL
            quantity = signal.get('quantity', 0)
            
            symbol_data = day_data[day_data['Symbol'] == symbol]
            if symbol_data.empty:
                return
            
            current_price = symbol_data['Close'].iloc[0]
            date = symbol_data['Date'].iloc[0]
            
            if action == 'BUY':
                await self._execute_buy(symbol, quantity, current_price, date, strategy_name)
            elif action == 'SELL':
                await self._execute_sell(symbol, quantity, current_price, date, strategy_name)
                
        except Exception as e:
            logger.error(f"Ïã†Ìò∏ Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
    
    async def _execute_buy(self, symbol: str, quantity: int, price: float, date: datetime, strategy: str):
        """Îß§Ïàò Ïã§Ìñâ"""
        try:
            # ÏàòÏàòÎ£å Î∞è Ïä¨Î¶¨ÌîºÏßÄ Ï†ÅÏö©
            adjusted_price = price * (1 + self.config['slippage_rate'])
            total_cost = quantity * adjusted_price * (1 + self.config['commission_rate'])
            
            if total_cost <= self.cash:
                # Í±∞Îûò Ïã§Ìñâ
                self.cash -= total_cost
                self.positions[symbol] = self.positions.get(symbol, 0) + quantity
                
                # Í±∞Îûò Í∏∞Î°ù
                trade = Trade(
                    symbol=symbol,
                    entry_date=date,
                    exit_date=None,
                    entry_price=adjusted_price,
                    exit_price=None,
                    quantity=quantity,
                    trade_type="BUY",
                    strategy=strategy
                )
                self.trades.append(trade)
                
                logger.debug(f"Îß§Ïàò Ïã§Ìñâ: {symbol} {quantity}Ï£º @ {adjusted_price:,.0f}")
                
        except Exception as e:
            logger.error(f"Îß§Ïàò Ïã§Ìñâ Ïò§Î•ò: {e}")
    
    async def _execute_sell(self, symbol: str, quantity: int, price: float, date: datetime, strategy: str):
        """Îß§ÎèÑ Ïã§Ìñâ"""
        try:
            if symbol in self.positions and self.positions[symbol] >= quantity:
                # ÏàòÏàòÎ£å Î∞è Ïä¨Î¶¨ÌîºÏßÄ Ï†ÅÏö©
                adjusted_price = price * (1 - self.config['slippage_rate'])
                total_proceeds = quantity * adjusted_price * (1 - self.config['commission_rate'])
                
                # Í±∞Îûò Ïã§Ìñâ
                self.cash += total_proceeds
                self.positions[symbol] -= quantity
                
                if self.positions[symbol] == 0:
                    del self.positions[symbol]
                
                # Í±∞Îûò Í∏∞Î°ù ÏóÖÎç∞Ïù¥Ìä∏ (Ìï¥Îãπ Ï¢ÖÎ™©Ïùò Í∞ÄÏû• Ïò§ÎûòÎêú Îß§Ïàò Í±∞Îûò Ï∞æÍ∏∞)
                for trade in self.trades:
                    if (trade.symbol == symbol and 
                        trade.trade_type == "BUY" and 
                        trade.exit_date is None):
                        
                        trade.exit_date = date
                        trade.exit_price = adjusted_price
                        trade.pnl = (adjusted_price - trade.entry_price) * quantity
                        trade.pnl_pct = (adjusted_price - trade.entry_price) / trade.entry_price * 100
                        break
                
                logger.debug(f"Îß§ÎèÑ Ïã§Ìñâ: {symbol} {quantity}Ï£º @ {adjusted_price:,.0f}")
                
        except Exception as e:
            logger.error(f"Îß§ÎèÑ Ïã§Ìñâ Ïò§Î•ò: {e}")
    
    def _should_rebalance(self, date: datetime) -> bool:
        """Î¶¨Î∞∏Îü∞Ïã± ÌïÑÏöî Ïó¨Î∂Ä ÌôïÏù∏"""
        if self.config['rebalance_frequency'] == "daily":
            return True
        elif self.config['rebalance_frequency'] == "weekly":
            return date.weekday() == 0  # ÏõîÏöîÏùº
        elif self.config['rebalance_frequency'] == "monthly":
            return date.day == 1  # Îß§Ïõî 1Ïùº
        return False
    
    async def _rebalance_portfolio(self, day_data: pd.DataFrame):
        """Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î¶¨Î∞∏Îü∞Ïã±"""
        # ÌòÑÏû¨Îäî Îã®Ïàú Íµ¨ÌòÑ, Ìñ•ÌõÑ Ï†ïÍµêÌïú Î¶¨Î∞∏Îü∞Ïã± Î°úÏßÅ Ï∂îÍ∞Ä
        pass
    
    def _calculate_performance(self) -> PerformanceMetrics:
        """ÏÑ±Í≥º ÏßÄÌëú Í≥ÑÏÇ∞"""
        try:
            if not self.portfolio_value:
                return PerformanceMetrics(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
            
            # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í∞ÄÏπò ÏãúÍ≥ÑÏó¥ ÏÉùÏÑ±
            df = pd.DataFrame(self.portfolio_value)
            df['Date'] = pd.to_datetime(df['Date'])
            df.set_index('Date', inplace=True)
            df['Returns'] = df['Value'].pct_change()
            
            # Í∏∞Î≥∏ ÏÑ±Í≥º ÏßÄÌëú
            total_return = (df['Value'].iloc[-1] - df['Value'].iloc[0]) / df['Value'].iloc[0] * 100
            annual_return = self._calculate_annual_return(df)
            volatility = df['Returns'].std() * np.sqrt(252) * 100
            sharpe_ratio = self._calculate_sharpe_ratio(df)
            max_drawdown = self._calculate_max_drawdown(df)
            
            # Í±∞Îûò Í¥ÄÎ†® ÏßÄÌëú
            completed_trades = [t for t in self.trades if t.exit_date is not None]
            win_trades = [t for t in completed_trades if t.pnl > 0]
            
            win_rate = len(win_trades) / len(completed_trades) * 100 if completed_trades else 0
            profit_factor = self._calculate_profit_factor(completed_trades)
            avg_trade_return = np.mean([t.pnl_pct for t in completed_trades]) if completed_trades else 0
            best_trade = max([t.pnl_pct for t in completed_trades]) if completed_trades else 0
            worst_trade = min([t.pnl_pct for t in completed_trades]) if completed_trades else 0
            
            # Í≥†Í∏â ÏßÄÌëú
            calmar_ratio = annual_return / abs(max_drawdown) if max_drawdown != 0 else 0
            sortino_ratio = self._calculate_sortino_ratio(df)
            beta, alpha = self._calculate_beta_alpha(df)
            information_ratio = self._calculate_information_ratio(df)
            
            return PerformanceMetrics(
                total_return=total_return,
                annual_return=annual_return,
                volatility=volatility,
                sharpe_ratio=sharpe_ratio,
                max_drawdown=max_drawdown,
                win_rate=win_rate,
                profit_factor=profit_factor,
                total_trades=len(completed_trades),
                avg_trade_return=avg_trade_return,
                best_trade=best_trade,
                worst_trade=worst_trade,
                calmar_ratio=calmar_ratio,
                sortino_ratio=sortino_ratio,
                beta=beta,
                alpha=alpha,
                information_ratio=information_ratio
            )
            
        except Exception as e:
            logger.error(f"ÏÑ±Í≥º ÏßÄÌëú Í≥ÑÏÇ∞ Ïò§Î•ò: {e}")
            return PerformanceMetrics(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    
    def _calculate_annual_return(self, df: pd.DataFrame) -> float:
        """Ïó∞Í∞Ñ ÏàòÏùµÎ•† Í≥ÑÏÇ∞"""
        days = (df.index[-1] - df.index[0]).days
        years = days / 365.25
        total_return = (df['Value'].iloc[-1] - df['Value'].iloc[0]) / df['Value'].iloc[0]
        return (1 + total_return) ** (1/years) - 1 if years > 0 else 0
    
    def _calculate_sharpe_ratio(self, df: pd.DataFrame) -> float:
        """ÏÉ§ÌîÑ ÎπÑÏú® Í≥ÑÏÇ∞"""
        excess_returns = df['Returns'] - self.config['risk_free_rate']/252  # Î¨¥ÏúÑÌóò ÏàòÏùµÎ•† 2.5% Í∞ÄÏ†ï
        return excess_returns.mean() / excess_returns.std() * np.sqrt(252) if excess_returns.std() != 0 else 0
    
    def _calculate_max_drawdown(self, df: pd.DataFrame) -> float:
        """ÏµúÎåÄ ÎÇôÌè≠ Í≥ÑÏÇ∞"""
        peak = df['Value'].expanding().max()
        drawdown = (df['Value'] - peak) / peak * 100
        return drawdown.min()
    
    def _calculate_profit_factor(self, trades: List[Trade]) -> float:
        """ÏàòÏùµ Ìå©ÌÑ∞ Í≥ÑÏÇ∞"""
        profits = sum([t.pnl for t in trades if t.pnl > 0])
        losses = abs(sum([t.pnl for t in trades if t.pnl < 0]))
        return profits / losses if losses != 0 else 0
    
    def _calculate_sortino_ratio(self, df: pd.DataFrame) -> float:
        """ÏÜåÎ•¥Ìã∞ÎÖ∏ ÎπÑÏú® Í≥ÑÏÇ∞"""
        negative_returns = df['Returns'][df['Returns'] < 0]
        downside_deviation = negative_returns.std() * np.sqrt(252)
        excess_return = df['Returns'].mean() * 252 - self.config['risk_free_rate']  # Î¨¥ÏúÑÌóò ÏàòÏùµÎ•† 2.5%
        return excess_return / downside_deviation if downside_deviation != 0 else 0
    
    def _calculate_beta_alpha(self, df: pd.DataFrame) -> Tuple[float, float]:
        """Î≤†ÌÉÄÏôÄ ÏïåÌåå Í≥ÑÏÇ∞"""
        if self.benchmark_data is None or self.benchmark_data.empty:
            return 0, 0
        
        try:
            # Î≤§ÏπòÎßàÌÅ¨ ÏàòÏùµÎ•† Í≥ÑÏÇ∞
            benchmark_returns = self.benchmark_data['Close'].pct_change().dropna()
            portfolio_returns = df['Returns'].dropna()
            
            # ÎÇ†Ïßú ÎßûÏ∂îÍ∏∞
            common_dates = portfolio_returns.index.intersection(benchmark_returns.index)
            if len(common_dates) < 2:
                return 0, 0
            
            portfolio_aligned = portfolio_returns.loc[common_dates]
            benchmark_aligned = benchmark_returns.loc[common_dates]
            
            # Î≤†ÌÉÄ Í≥ÑÏÇ∞
            covariance = np.cov(portfolio_aligned, benchmark_aligned)[0, 1]
            benchmark_variance = np.var(benchmark_aligned)
            beta = covariance / benchmark_variance if benchmark_variance != 0 else 0
            
            # ÏïåÌåå Í≥ÑÏÇ∞
            portfolio_mean = portfolio_aligned.mean() * 252
            benchmark_mean = benchmark_aligned.mean() * 252
            alpha = portfolio_mean - (self.config['risk_free_rate'] + beta * (benchmark_mean - self.config['risk_free_rate']))
            
            return beta, alpha
            
        except Exception as e:
            logger.error(f"Î≤†ÌÉÄ/ÏïåÌåå Í≥ÑÏÇ∞ Ïò§Î•ò: {e}")
            return 0, 0
    
    def _calculate_information_ratio(self, df: pd.DataFrame) -> float:
        """Ï†ïÎ≥¥ ÎπÑÏú® Í≥ÑÏÇ∞"""
        if self.benchmark_data is None or self.benchmark_data.empty:
            return 0
        
        try:
            benchmark_returns = self.benchmark_data['Close'].pct_change().dropna()
            portfolio_returns = df['Returns'].dropna()
            
            common_dates = portfolio_returns.index.intersection(benchmark_returns.index)
            if len(common_dates) < 2:
                return 0
            
            portfolio_aligned = portfolio_returns.loc[common_dates]
            benchmark_aligned = benchmark_returns.loc[common_dates]
            
            excess_returns = portfolio_aligned - benchmark_aligned
            tracking_error = excess_returns.std() * np.sqrt(252)
            
            return excess_returns.mean() * 252 / tracking_error if tracking_error != 0 else 0
            
        except Exception as e:
            logger.error(f"Ï†ïÎ≥¥ ÎπÑÏú® Í≥ÑÏÇ∞ Ïò§Î•ò: {e}")
            return 0
    
    def _save_results(self, strategy_name: str, performance: PerformanceMetrics) -> int:
        """Í≤∞Í≥º Ï†ÄÏû•"""
        try:
            conn = sqlite3.connect(self.results_db)
            cursor = conn.cursor()
            
            # Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥º Ï†ÄÏû•
            cursor.execute('''
                INSERT INTO backtest_results 
                (strategy_name, start_date, end_date, total_return, annual_return, 
                 sharpe_ratio, max_drawdown, win_rate, total_trades, config)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                strategy_name,
                self.config['start_date'],
                self.config['end_date'],
                performance.total_return,
                performance.annual_return,
                performance.sharpe_ratio,
                performance.max_drawdown,
                performance.win_rate,
                performance.total_trades,
                json.dumps(self.config)
            ))
            
            backtest_id = cursor.lastrowid
            
            # Í±∞Îûò Í∏∞Î°ù Ï†ÄÏû•
            for trade in self.trades:
                if trade.exit_date is not None:
                    cursor.execute('''
                        INSERT INTO trade_history 
                        (backtest_id, symbol, entry_date, exit_date, entry_price, 
                         exit_price, quantity, pnl, pnl_pct, strategy)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        backtest_id,
                        trade.symbol,
                        trade.entry_date.isoformat(),
                        trade.exit_date.isoformat(),
                        trade.entry_price,
                        trade.exit_price,
                        trade.quantity,
                        trade.pnl,
                        trade.pnl_pct,
                        trade.strategy
                    ))
            
            conn.commit()
            conn.close()
            
            return backtest_id
            
        except Exception as e:
            logger.error(f"Í≤∞Í≥º Ï†ÄÏû• Ïò§Î•ò: {e}")
            return -1
    
    def _generate_report(self, performance: PerformanceMetrics, strategy_name: str) -> str:
        """Î∞±ÌÖåÏä§Ìä∏ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±"""
        report = f"""
=== Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥º Î¶¨Ìè¨Ìä∏ ===
Ï†ÑÎûµÎ™Ö: {strategy_name}
Í∏∞Í∞Ñ: {self.config['start_date']} ~ {self.config['end_date']}
Ï¥àÍ∏∞ ÏûêÎ≥∏: {self.config['initial_capital']:,.0f}Ïõê

=== ÏàòÏùµÎ•† ÏßÄÌëú ===
Ï¥ù ÏàòÏùµÎ•†: {performance.total_return:.2f}%
Ïó∞Í∞Ñ ÏàòÏùµÎ•†: {performance.annual_return:.2f}%
Î≥ÄÎèôÏÑ±: {performance.volatility:.2f}%
ÏÉ§ÌîÑ ÎπÑÏú®: {performance.sharpe_ratio:.2f}
ÏµúÎåÄ ÎÇôÌè≠: {performance.max_drawdown:.2f}%

=== Í±∞Îûò ÏßÄÌëú ===
Ï¥ù Í±∞Îûò ÌöüÏàò: {performance.total_trades}
ÏäπÎ•†: {performance.win_rate:.2f}%
ÏàòÏùµ Ìå©ÌÑ∞: {performance.profit_factor:.2f}
ÌèâÍ∑† Í±∞Îûò ÏàòÏùµÎ•†: {performance.avg_trade_return:.2f}%
ÏµúÍ≥† Í±∞Îûò: {performance.best_trade:.2f}%
ÏµúÏïÖ Í±∞Îûò: {performance.worst_trade:.2f}%

=== Í≥†Í∏â ÏßÄÌëú ===
ÏπºÎßà ÎπÑÏú®: {performance.calmar_ratio:.2f}
ÏÜåÎ•¥Ìã∞ÎÖ∏ ÎπÑÏú®: {performance.sortino_ratio:.2f}
Î≤†ÌÉÄ: {performance.beta:.2f}
ÏïåÌåå: {performance.alpha:.2f}%
Ï†ïÎ≥¥ ÎπÑÏú®: {performance.information_ratio:.2f}
"""
        return report
    
    def generate_charts(self, backtest_id: int, output_dir: str = "reports"):
        """Ï∞®Ìä∏ ÏÉùÏÑ±"""
        try:
            Path(output_dir).mkdir(exist_ok=True)
            
            # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í∞ÄÏπò Ï∞®Ìä∏
            df = pd.DataFrame(self.portfolio_value)
            df['Date'] = pd.to_datetime(df['Date'])
            
            plt.figure(figsize=(15, 10))
            
            # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í∞ÄÏπò Ï∂îÏù¥
            plt.subplot(2, 2, 1)
            plt.plot(df['Date'], df['Value'])
            plt.title('Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í∞ÄÏπò Ï∂îÏù¥')
            plt.xlabel('ÎÇ†Ïßú')
            plt.ylabel('Í∞ÄÏπò (Ïõê)')
            plt.xticks(rotation=45)
            
            # ÏùºÎ≥Ñ ÏàòÏùµÎ•† Î∂ÑÌè¨
            plt.subplot(2, 2, 2)
            returns = df['Value'].pct_change().dropna() * 100
            plt.hist(returns, bins=50, alpha=0.7)
            plt.title('ÏùºÎ≥Ñ ÏàòÏùµÎ•† Î∂ÑÌè¨')
            plt.xlabel('ÏàòÏùµÎ•† (%)')
            plt.ylabel('ÎπàÎèÑ')
            
            # ÎìúÎ°úÏö∞Îã§Ïö¥ Ï∞®Ìä∏
            plt.subplot(2, 2, 3)
            peak = df['Value'].expanding().max()
            drawdown = (df['Value'] - peak) / peak * 100
            plt.fill_between(df['Date'], drawdown, 0, alpha=0.3, color='red')
            plt.title('ÎìúÎ°úÏö∞Îã§Ïö¥')
            plt.xlabel('ÎÇ†Ïßú')
            plt.ylabel('ÎìúÎ°úÏö∞Îã§Ïö¥ (%)')
            plt.xticks(rotation=45)
            
            # ÏõîÎ≥Ñ ÏàòÏùµÎ•† ÌûàÌä∏Îßµ
            plt.subplot(2, 2, 4)
            df['Month'] = df['Date'].dt.month
            df['Year'] = df['Date'].dt.year
            monthly_returns = df.groupby(['Year', 'Month'])['Value'].last().pct_change() * 100
            monthly_returns = monthly_returns.unstack(level=1)
            
            if not monthly_returns.empty:
                sns.heatmap(monthly_returns, annot=True, fmt='.1f', cmap='RdYlGn', center=0)
                plt.title('ÏõîÎ≥Ñ ÏàòÏùµÎ•† ÌûàÌä∏Îßµ')
            
            plt.tight_layout()
            plt.savefig(f"{output_dir}/backtest_{backtest_id}_charts.png", dpi=300, bbox_inches='tight')
            plt.close()
            
            logger.info(f"Ï∞®Ìä∏ ÏÉùÏÑ± ÏôÑÎ£å: {output_dir}/backtest_{backtest_id}_charts.png")
            
        except Exception as e:
            logger.error(f"Ï∞®Ìä∏ ÏÉùÏÑ± Ïò§Î•ò: {e}")

# ÏÇ¨Ïö© ÏòàÏ†ú
async def example_strategy(day_data: pd.DataFrame, positions: Dict[str, int]) -> List[Dict[str, Any]]:
    """ÏòàÏ†ú Ï†ÑÎûµ - Îã®Ïàú Ïù¥ÎèôÌèâÍ∑† Ï†ÑÎûµ"""
    signals = []
    
    for _, row in day_data.iterrows():
        symbol = row['Symbol']
        close_price = row['Close']
        
        # Îã®ÏàúÌïú ÏòàÏ†ú: ÏûÑÏùòÏùò Ï°∞Í±¥ÏúºÎ°ú Îß§Îß§ Ïã†Ìò∏ ÏÉùÏÑ±
        if symbol not in positions:
            # Îß§Ïàò Ïã†Ìò∏
            signals.append({
                'symbol': symbol,
                'action': 'BUY',
                'quantity': 100
            })
    
    return signals 