---
alwaysApply: true
---
# 🚀 세계 최고 수준 AI 트레이딩봇 개발 

## 🎯 Phase 1: 프로젝트 초기화 (World-Class 표준)

```
🏆 Google/Meta/Netflix 수준의 AI 자동매매봇을 개발해줘

모든코딩을 할때 효율성과 유지보수성을 최우선으로 최신python문법으로 단순하게 코딩해줘
모든 응답은 한국어로해줘 코드수정은 캔버스에 자동저장되게 해줘
효율적인 것은 “중복 없는 단일화 + 모듈화 + 자동화 + 확장성”으로 코딩해줘
하나의 통합 파이프라인/모듈로 관리할수있게 가장 효율적으로 코딩해줘
코딩요청할때 기존파일 업그레이드가 좋을지 새파일생성이좋을지 전체파일 검토해서 효율적으로 결정해줘  


📋 프로젝트 요구사항:
- 국내/해외 주식, 선물, 옵션, ETF(거래대금 8위)
- 실시간 + 과거 데이터 최대치로 ML/DL 학습 능력 극대화
- 데이트레이딩/스윙트레이딩/중기투자 시장 상황별 자동 전략 전환
- 종목 자동 선별 및 매수/매도 의사결정 완전 자동화
- 안정성과 유지보수를 우선하고 비동기 초초고속 병렬처리,멀티레벨캐싱,커넥션풀링 등 
  효율적으로 속도 성능 메모리 최적화로 코딩 해줘


🎨 코드 품질 기준:
- Zero Bug Tolerance: 런타임 에러 완전 차단
- Performance Excellence: 동급 대비 2배+ 성능
- Security First: OWASP Top 10 완전 방어
- Production Ready: SLA 99.9% 달성 가능

🏗️ 아키텍처 원칙:
- SOLID Principles + Clean Architecture 적용
- Domain Driven Design 중심 설계
- 마이크로서비스 아키텍처 (독립 배포 가능)
- Event-Driven + CQRS 패턴

📁 정확한 폴더 구조로 생성해줘:
[여기에 첨부된 AI_SmartTrader 구조 붙여넣기]

먼저 core/config/ 폴더부터 세계 최고 수준으로 만들어줘.
```

## 🔧 Phase 2: 핵심 설정 시스템 (Production Grade)

```
core/config/ 모듈을 Google 수준으로 구현해줘:

📂 core/config/
├── __init__.py              # 설정 시스템 초기화
├── global_settings.py       # 전역 설정 (환경별 분리)
├── api_config.py           # API 설정 (한투, DART, KRX 등)
├── trading_config.py       # 거래 설정 (리스크, 포지션 사이징)
├── ml_config.py            # ML/DL 모델 하이퍼파라미터
├── market_config.py        # 마켓별 설정 (주식/선물/옵션)
└── logging_config.py       # 구조화된 로깅 설정

🎯 구현 요구사항:
1. Pydantic BaseSettings로 타입 안전한 설정 관리
2. 환경별 설정 분리 (dev/staging/prod)
3. 민감 정보 환경변수 분리 + 암호화
4. 설정 변경 시 Hot Reload 지원
5. 설정 검증 및 기본값 제공
6. Structured Logging (JSON 형태)

🔒 보안 요구사항:
- API 키 암호화 저장
- 설정 파일 권한 제한
- 로그에서 민감 정보 마스킹
- 런타임 설정 검증

📊 성능 요구사항:
- 설정 로딩 < 100ms
- 메모리 사용량 < 10MB
- CPU 사용률 < 1%

모든 파일에 완벽한 타입 힌트, docstring, 에러 핸들링 포함해줘.
```

## 🧠 Phase 3: AI 브레인 시스템 (Deep Learning Excellence)

```
ai_brain/ 모듈을 Meta AI 수준으로 구현해줘:

📂 ai_brain/models/predictive/
├── price_predictor.py       # 가격 예측 (Transformer + LSTM 앙상블)
├── direction_predictor.py   # 방향성 예측 (CNN + Attention)
├── volatility_predictor.py  # 변동성 예측 (GARCH + Neural Net)
└── volume_predictor.py      # 거래량 예측 (GRU + XGBoost)

🤖 AI 아키텍처 요구사항:
1. Multi-Modal 입력 (가격/거래량/뉴스/감성/경제지표)
2. Attention Mechanism으로 중요 피처 자동 선별
3. Transfer Learning으로 해외 시장 지식 활용
4. Online Learning으로 실시간 학습 적응
5. Ensemble Method로 예측 정확도 극대화

🎯 성능 목표:
- 예측 정확도: 65%+ (일일 방향성)
- 추론 속도: < 50ms per prediction
- 메모리 효율: < 2GB for all models
- GPU 활용률: 95%+

🔬 모델 구성:
- LSTM: 시계열 패턴 학습
- Transformer: Long-range dependency 포착
- CNN: 차트 패턴 인식
- Attention: 중요 시점 식별
- XGBoost: 구조화된 데이터 처리

각 모델에 하이퍼파라미터 자동 튜닝, 교차 검증, A/B 테스트 포함해줘.
```

## 📊 Phase 4: 데이터 엔진 (Big Data Processing)

```
data_engine/ 모듈을 Netflix 수준으로 구현해줘:

📂 data_engine/collectors/market_data/
├── kis_collector.py         # 한투 API (REST + WebSocket)
├── dart_collector.py        # DART API (재무제표/공시)
├── krx_collector.py         # KRX API (시장 데이터)
└── alternative_collector.py  # 뉴스/소셜/경제지표

⚡ 실시간 데이터 처리:
1. WebSocket 다중 연결 (fail-over 지원)
2. 데이터 스트리밍 파이프라인 (Apache Kafka 수준)
3. 실시간 데이터 정제 및 검증
4. 지연시간 < 10ms (시장 데이터)
5. 처리량 > 100,000 msg/sec

💾 과거 데이터 수집:
- 주식: 20년치 일/분/틱 데이터
- 선물/옵션: 전 시리즈 과거 데이터
- ETF: 거래대금 상위 10위 동적 업데이트
- 재무제표: 10년치 분기별 상세 데이터
- 뉴스/공시: 5년치 텍스트 데이터

🔄 데이터 파이프라인:
1. Extract: 다중 소스 병렬 수집
2. Transform: 실시간 정제/정규화/피처 생성
3. Load: 시계열 DB (InfluxDB) + 관계형 DB (PostgreSQL)
4. Validate: 데이터 품질 자동 검증
5. Monitor: 수집 상태 실시간 모니터링

Circuit Breaker, Retry Logic, Dead Letter Queue 포함해줘.
```

## ⚡ Phase 5: 전략 엔진 (Algorithmic Trading)

```
strategy_engine/ 모듈을 Renaissance Technologies 수준으로 구현해줘:

📂 strategy_engine/strategy_factory/
├── daytrading/
│   ├── scalping_strategy.py     # 초단기 매매 (1-5분)
│   ├── momentum_strategy.py     # 모멘텀 전략
│   └── mean_reversion.py        # 평균 회귀 전략
├── swing_trading/
│   ├── trend_following.py       # 추세 추종 (1-10일)
│   ├── pairs_trading.py         # 페어 트레이딩
│   └── sector_rotation.py       # 섹터 로테이션
└── medium_term/
    ├── factor_strategy.py       # 팩터 투자 (1-3개월)
    ├── value_strategy.py        # 가치 투자
    └── growth_strategy.py       # 성장 투자

🧠 지능형 전략 선택:
1. 시장 국면 자동 감지 (Bull/Bear/Sideways + Volatility)
2. 전략별 실시간 성과 추적 및 비교
3. Dynamic Weight Allocation (켈리 기준 + 블랙-리터만)
4. Risk-Adjusted Return 최적화
5. 전략 간 상관관계 분석으로 다각화

🎯 성능 지표:
- Sharpe Ratio > 2.0
- Maximum Drawdown < 10%
- Win Rate > 60%
- Profit Factor > 1.5

🔄 적응형 알고리즘:
- 시장 변화 감지 시 전략 자동 전환
- 성과 하락 시 포지션 축소
- 변동성 증가 시 리스크 관리 강화
- 유동성 부족 시 주문 분할 실행

모든 전략에 백테스팅, 워크포워드 분석, 몬테카를로 시뮬레이션 포함해줘.
```

## 🛡️ Phase 6: 리스크 관리 시스템 (Institutional Grade)

```
execution_engine/risk_management/ 모듈을 Goldman Sachs 수준으로 구현해줘:

📂 risk_management/
├── position_sizer.py        # 포지션 사이징 (동적)
├── exposure_manager.py      # 익스포저 관리 (섹터/지역별)
├── var_calculator.py        # VaR/CVaR 실시간 계산
├── stress_tester.py         # 스트레스 테스트
└── drawdown_controller.py   # 드로우다운 제어

🛡️ 리스크 모델:
1. Portfolio-level VaR (99% 신뢰구간)
2. 개별 종목 Risk Contribution 분석
3. 섹터/지역별 집중도 리스크 모니터링
4. 유동성 리스크 측정 (Bid-Ask Spread 분석)
5. 상관관계 변화 실시간 추적

⚠️ 자동 리스크 제어:
- 일일 손실 한도 도달 시 모든 포지션 청산
- VaR 임계치 초과 시 포지션 자동 축소
- 유동성 부족 시 주문 분할 또는 취소
- 시장 급변 시 Emergency Stop

📊 실시간 모니터링:
- 포트폴리오 Greeks (Delta, Gamma, Vega, Theta)
- Sector Exposure Heat Map
- Correlation Matrix 실시간 업데이트
- Stress Scenario P&L 시뮬레이션

모든 리스크 지표에 Alert 시스템과 자동 대응 로직 포함해줘.
```

## 🚀 Phase 7: 실행 엔진 (Ultra-Low Latency)

```
execution_engine/order_management/ 모듈을 Citadel Securities 수준으로 구현해줘:

📂 order_management/
├── order_router.py          # 스마트 주문 라우팅
├── order_tracker.py         # 주문 추적 및 관리
├── fill_manager.py          # 체결 관리
├── slippage_estimator.py    # 슬리피지 예측
└── market_maker.py          # 마켓 메이킹 로직

⚡ Ultra-Low Latency 요구사항:
- 주문 전송 지연: < 1ms
- 체결 확인 처리: < 5ms
- 시장 데이터 처리: < 100μs
- 메모리 지역성 최적화
- Lock-free 알고리즘 사용

🎯 스마트 실행 알고리즘:
1. TWAP/VWAP 기반 주문 분할
2. Market Impact 최소화
3. 유동성 Pool 간 가격 비교
4. Hidden/Iceberg 주문 지원
5. Post-only 전략으로 수수료 최적화

📊 실행 품질 측정:
- Implementation Shortfall 추적
- Slippage vs Benchmark 비교
- Fill Rate 및 Time to Fill 분석
- Market Impact 측정
- 수수료 효율성 분석

🔄 Fail-safe 메커니즘:
- 네트워크 단절 시 자동 재연결
- API 장애 시 백업 경로 활성화
- 주문 확인 실패 시 재전송
- 시스템 과부하 시 주문 대기

모든 주문에 완벽한 Audit Trail과 Compliance 체크 포함해줘.
```

## 📊 Phase 8: 모니터링 센터 (Observability)

```
monitoring_center/ 모듈을 Datadog 수준으로 구현해줘:

📂 monitoring_center/
├── performance/
│   ├── portfolio_tracker.py    # 실시간 포트폴리오 추적
│   ├── pnl_analyzer.py        # 손익 분석 (실시간)
│   └── attribution_analyzer.py # 수익 기여도 분석
├── alerts/
│   ├── smart_alerting.py      # ML 기반 이상 감지
│   └── notification_hub.py    # 멀티 채널 알림
└── dashboards/
    ├── executive_dashboard.py  # 경영진용 대시보드
    └── trader_dashboard.py     # 트레이더용 대시보드

📊 실시간 메트릭:
1. Trading Metrics (Sharpe, Sortino, Calmar Ratio)
2. System Metrics (Latency, Throughput, Error Rate)
3. Risk Metrics (VaR, Exposure, Concentration)
4. Market Metrics (Volatility, Correlation, Beta)
5. Operational Metrics (Uptime, Fill Rate, Slippage)

🚨 Intelligent Alerting:
- Anomaly Detection으로 이상 패턴 자동 감지
- Alert Fatigue 방지를 위한 우선순위 기반 필터링
- Escalation Policy (심각도별 담당자 자동 배정)
- Alert Correlation (관련 이벤트 그룹핑)

📈 대시보드 기능:
- 실시간 P&L 차트 (드릴다운 지원)
- 포지션 히트맵 (섹터/지역별)
- 실행 품질 분석 (vs 벤치마크)
- 시장 상황 요약 (한눈에 보는 시장 현황)

모든 대시보드에 WebSocket 실시간 업데이트와 모바일 최적화 포함해줘.
```

## 🧪 Phase 9: 백테스팅 연구소 (Quantitative Research)

```
backtesting_lab/ 모듈을 Two Sigma 수준으로 구현해줘:

📂 backtesting_lab/
├── engines/
│   ├── vectorized_engine.py     # 대용량 데이터 벡터화 처리
│   ├── event_driven_engine.py   # 실제 거래 환경 시뮬레이션
│   └── monte_carlo_engine.py    # 몬테카를로 시뮬레이션
├── analyzers/
│   ├── performance_analyzer.py  # 심화 성과 분석
│   ├── risk_analyzer.py        # 리스크 분해 분석
│   └── factor_analyzer.py      # 팩터 기여도 분석
└── reports/
    ├── research_report.py      # 자동 리서치 리포트 생성
    └── tearsheet_generator.py  # Quantopian 스타일 Tearsheet

🔬 고급 백테스팅 기능:
1. Walk-Forward Analysis (Out-of-Sample 검증)
2. Regime-Aware Backtesting (시장 국면별 분석)
3. Transaction Cost Model (실제 비용 반영)
4. Market Impact Model (호가창 임팩트 시뮬레이션)
5. Slippage Model (실제 체결가 시뮬레이션)

📊 백테스트 결과 분석:
- Rolling Performance Metrics
- Underwater Curve (드로우다운 기간 분석)
- Returns Distribution Analysis
- Tail Risk Metrics (Skewness, Kurtosis)
- Strategy Capacity Analysis

🎯 연구 도구:
- Factor Research Framework
- Alpha Decay Analysis
- Strategy Combination Optimizer
- Parameter Sensitivity Analysis
- Regime-Based Strategy Selection

모든 백테스트에 Statistical Significance Test와 Multiple Testing Correction 포함해줘.
```

## 🌐 Phase 10: 통합 시스템 (Full Integration)

```
최종 통합 및 Production 배포를 위한 시스템을 구축해줘:

🔄 시스템 오케스트레이션:
1. main_orchestrator.py - 전체 시스템 조율
2. 서비스 간 통신 (gRPC + Message Queue)
3. Circuit Breaker Pattern 구현
4. Health Check 및 Service Discovery
5. Graceful Shutdown 및 Restart

🚀 배포 시스템:
- Docker 멀티 스테이지 빌드
- Kubernetes 오케스트레이션
- Blue-Green 배포 전략
- Rolling Update 지원
- Canary 배포 for 전략 업데이트

📊 종합 성능 목표:
- 시스템 가용성: 99.95%+
- 평균 응답시간: < 50ms
- 처리량: 100,000+ 이벤트/초
- 메모리 사용량: < 8GB
- CPU 사용률: < 70%

🔒 보안 및 컴플라이언스:
- 모든 통신 TLS 암호화
- API 키 Vault 저장
- 접근 권한 RBAC 관리
- 모든 거래 Audit Log
- GDPR/개인정보보호법 준수

전체 시스템이 Google/Meta/Netflix 수준의 신뢰성과 성능을 달성하도록 구현해줘.
```

## 💡 각 Phase별 실행 방법

### 🎯 단계별 실행 가이드

**Phase 1-2**: 기반 인프라 (1주)
```
"Phase 1과 2를 실행해줘: 프로젝트 초기화 + 핵심 설정 시스템"
```

**Phase 3-4**: 데이터 + AI (2주)
```
"Phase 3과 4를 실행해줘: AI 브레인 + 데이터 엔진"
```

**Phase 5-6**: 전략 + 리스크 (2주)
```
"Phase 5와 6을 실행해줘: 전략 엔진 + 리스크 관리"
```

**Phase 7-8**: 실행 + 모니터링 (1주)
```
"Phase 7과 8을 실행해줘: 실행 엔진 + 모니터링"
```

**Phase 9-10**: 백테스팅 + 통합 (1주)
```
"Phase 9와 10을 실행해줘: 백테스팅 + 통합 시스템"
```

### 🔧 각 Phase 완료 후 확인사항

```
Phase 완료 후 다음을 확인해줘:

1. mypy --strict 통과 (100% 타입 안전)
2. pytest 실행 (95%+ 커버리지)
3. black + flake8 + isort 통과
4. 성능 벤치마크 달성
5. 보안 취약점 스캔 통과
6. 문서 자동 생성 성공
7. Docker 빌드 성공
8. 통합 테스트 통과

문제 발생 시 구체적인 해결책 제시해줘.
```

이 프롬프트로 실행하면 정말 세계 최고 수준의 AI 트레이딩봇이 완성될 거예요! 🚀# 🚀 세계 최고 수준 AI 트레이딩봇 개발 프롬프트

## 🎯 Phase 1: 프로젝트 초기화 (World-Class 표준)

```
🏆 Google/Meta/Netflix 수준의 AI 자동매매봇을 개발해줘.

📋 프로젝트 요구사항:
- 국내/해외 주식, 선물, 옵션, ETF(거래대금 10위) 멀티 자산 지원
- 실시간 + 과거 데이터 최대치로 ML/DL 학습 능력 극대화
- 데이트레이딩/스윙트레이딩/중기투자 시장 상황별 자동 전략 전환
- 종목 자동 선별 및 매수/매도 의사결정 완전 자동화

🎨 코드 품질 기준:
- Zero Bug Tolerance: 런타임 에러 완전 차단
- Performance Excellence: 동급 대비 2배+ 성능
- Security First: OWASP Top 10 완전 방어
- Production Ready: SLA 99.9% 달성 가능

🏗️ 아키텍처 원칙:
- SOLID Principles + Clean Architecture 적용
- Domain Driven Design 중심 설계
- 마이크로서비스 아키텍처 (독립 배포 가능)
- Event-Driven + CQRS 패턴

📁 정확한 폴더 구조로 생성해줘:
[여기에 첨부된 AI_SmartTrader 구조 붙여넣기]

먼저 core/config/ 폴더부터 세계 최고 수준으로 만들어줘.
```

## 🔧 Phase 2: 핵심 설정 시스템 (Production Grade)

```
core/config/ 모듈을 Google 수준으로 구현해줘:

📂 core/config/
├── __init__.py              # 설정 시스템 초기화
├── global_settings.py       # 전역 설정 (환경별 분리)
├── api_config.py           # API 설정 (한투, DART, KRX 등)
├── trading_config.py       # 거래 설정 (리스크, 포지션 사이징)
├── ml_config.py            # ML/DL 모델 하이퍼파라미터
├── market_config.py        # 마켓별 설정 (주식/선물/옵션)
└── logging_config.py       # 구조화된 로깅 설정

🎯 구현 요구사항:
1. Pydantic BaseSettings로 타입 안전한 설정 관리
2. 환경별 설정 분리 (dev/staging/prod)
3. 민감 정보 환경변수 분리 + 암호화
4. 설정 변경 시 Hot Reload 지원
5. 설정 검증 및 기본값 제공
6. Structured Logging (JSON 형태)

🔒 보안 요구사항:
- API 키 암호화 저장
- 설정 파일 권한 제한
- 로그에서 민감 정보 마스킹
- 런타임 설정 검증

📊 성능 요구사항:
- 설정 로딩 < 100ms
- 메모리 사용량 < 10MB
- CPU 사용률 < 1%

모든 파일에 완벽한 타입 힌트, docstring, 에러 핸들링 포함해줘.
```

## 🧠 Phase 3: AI 브레인 시스템 (Deep Learning Excellence)

```
ai_brain/ 모듈을 Meta AI 수준으로 구현해줘:

📂 ai_brain/models/predictive/
├── price_predictor.py       # 가격 예측 (Transformer + LSTM 앙상블)
├── direction_predictor.py   # 방향성 예측 (CNN + Attention)
├── volatility_predictor.py  # 변동성 예측 (GARCH + Neural Net)
└── volume_predictor.py      # 거래량 예측 (GRU + XGBoost)

🤖 AI 아키텍처 요구사항:
1. Multi-Modal 입력 (가격/거래량/뉴스/감성/경제지표)
2. Attention Mechanism으로 중요 피처 자동 선별
3. Transfer Learning으로 해외 시장 지식 활용
4. Online Learning으로 실시간 학습 적응
5. Ensemble Method로 예측 정확도 극대화

🎯 성능 목표:
- 예측 정확도: 65%+ (일일 방향성)
- 추론 속도: < 50ms per prediction
- 메모리 효율: < 2GB for all models
- GPU 활용률: 95%+

🔬 모델 구성:
- LSTM: 시계열 패턴 학습
- Transformer: Long-range dependency 포착
- CNN: 차트 패턴 인식
- Attention: 중요 시점 식별
- XGBoost: 구조화된 데이터 처리

각 모델에 하이퍼파라미터 자동 튜닝, 교차 검증, A/B 테스트 포함해줘.
```

## 📊 Phase 4: 데이터 엔진 (Big Data Processing)

```
data_engine/ 모듈을 Netflix 수준으로 구현해줘:

📂 data_engine/collectors/market_data/
├── kis_collector.py         # 한투 API (REST + WebSocket)
├── dart_collector.py        # DART API (재무제표/공시)
├── krx_collector.py         # KRX API (시장 데이터)
└── alternative_collector.py  # 뉴스/소셜/경제지표

⚡ 실시간 데이터 처리:
1. WebSocket 다중 연결 (fail-over 지원)
2. 데이터 스트리밍 파이프라인 (Apache Kafka 수준)
3. 실시간 데이터 정제 및 검증
4. 지연시간 < 10ms (시장 데이터)
5. 처리량 > 100,000 msg/sec

💾 과거 데이터 수집:
- 주식: 20년치 일/분/틱 데이터
- 선물/옵션: 전 시리즈 과거 데이터
- ETF: 거래대금 상위 10위 동적 업데이트
- 재무제표: 10년치 분기별 상세 데이터
- 뉴스/공시: 5년치 텍스트 데이터

🔄 데이터 파이프라인:
1. Extract: 다중 소스 병렬 수집
2. Transform: 실시간 정제/정규화/피처 생성
3. Load: 시계열 DB (InfluxDB) + 관계형 DB (PostgreSQL)
4. Validate: 데이터 품질 자동 검증
5. Monitor: 수집 상태 실시간 모니터링

Circuit Breaker, Retry Logic, Dead Letter Queue 포함해줘.
```

## ⚡ Phase 5: 전략 엔진 (Algorithmic Trading)

```
strategy_engine/ 모듈을 Renaissance Technologies 수준으로 구현해줘:

📂 strategy_engine/strategy_factory/
├── daytrading/
│   ├── scalping_strategy.py     # 초단기 매매 (1-5분)
│   ├── momentum_strategy.py     # 모멘텀 전략
│   └── mean_reversion.py        # 평균 회귀 전략
├── swing_trading/
│   ├── trend_following.py       # 추세 추종 (1-10일)
│   ├── pairs_trading.py         # 페어 트레이딩
│   └── sector_rotation.py       # 섹터 로테이션
└── medium_term/
    ├── factor_strategy.py       # 팩터 투자 (1-3개월)
    ├── value_strategy.py        # 가치 투자
    └── growth_strategy.py       # 성장 투자

🧠 지능형 전략 선택:
1. 시장 국면 자동 감지 (Bull/Bear/Sideways + Volatility)
2. 전략별 실시간 성과 추적 및 비교
3. Dynamic Weight Allocation (켈리 기준 + 블랙-리터만)
4. Risk-Adjusted Return 최적화
5. 전략 간 상관관계 분석으로 다각화

🎯 성능 지표:
- Sharpe Ratio > 2.0
- Maximum Drawdown < 10%
- Win Rate > 60%
- Profit Factor > 1.5

🔄 적응형 알고리즘:
- 시장 변화 감지 시 전략 자동 전환
- 성과 하락 시 포지션 축소
- 변동성 증가 시 리스크 관리 강화
- 유동성 부족 시 주문 분할 실행

모든 전략에 백테스팅, 워크포워드 분석, 몬테카를로 시뮬레이션 포함해줘.
```

## 🛡️ Phase 6: 리스크 관리 시스템 (Institutional Grade)

```
execution_engine/risk_management/ 모듈을 Goldman Sachs 수준으로 구현해줘:

📂 risk_management/
├── position_sizer.py        # 포지션 사이징 (동적)
├── exposure_manager.py      # 익스포저 관리 (섹터/지역별)
├── var_calculator.py        # VaR/CVaR 실시간 계산
├── stress_tester.py         # 스트레스 테스트
└── drawdown_controller.py   # 드로우다운 제어

🛡️ 리스크 모델:
1. Portfolio-level VaR (99% 신뢰구간)
2. 개별 종목 Risk Contribution 분석
3. 섹터/지역별 집중도 리스크 모니터링
4. 유동성 리스크 측정 (Bid-Ask Spread 분석)
5. 상관관계 변화 실시간 추적

⚠️ 자동 리스크 제어:
- 일일 손실 한도 도달 시 모든 포지션 청산
- VaR 임계치 초과 시 포지션 자동 축소
- 유동성 부족 시 주문 분할 또는 취소
- 시장 급변 시 Emergency Stop

📊 실시간 모니터링:
- 포트폴리오 Greeks (Delta, Gamma, Vega, Theta)
- Sector Exposure Heat Map
- Correlation Matrix 실시간 업데이트
- Stress Scenario P&L 시뮬레이션

모든 리스크 지표에 Alert 시스템과 자동 대응 로직 포함해줘.
```

## 🚀 Phase 7: 실행 엔진 (Ultra-Low Latency)

```
execution_engine/order_management/ 모듈을 Citadel Securities 수준으로 구현해줘:

📂 order_management/
├── order_router.py          # 스마트 주문 라우팅
├── order_tracker.py         # 주문 추적 및 관리
├── fill_manager.py          # 체결 관리
├── slippage_estimator.py    # 슬리피지 예측
└── market_maker.py          # 마켓 메이킹 로직

⚡ Ultra-Low Latency 요구사항:
- 주문 전송 지연: < 1ms
- 체결 확인 처리: < 5ms
- 시장 데이터 처리: < 100μs
- 메모리 지역성 최적화
- Lock-free 알고리즘 사용

🎯 스마트 실행 알고리즘:
1. TWAP/VWAP 기반 주문 분할
2. Market Impact 최소화
3. 유동성 Pool 간 가격 비교
4. Hidden/Iceberg 주문 지원
5. Post-only 전략으로 수수료 최적화

📊 실행 품질 측정:
- Implementation Shortfall 추적
- Slippage vs Benchmark 비교
- Fill Rate 및 Time to Fill 분석
- Market Impact 측정
- 수수료 효율성 분석

🔄 Fail-safe 메커니즘:
- 네트워크 단절 시 자동 재연결
- API 장애 시 백업 경로 활성화
- 주문 확인 실패 시 재전송
- 시스템 과부하 시 주문 대기

모든 주문에 완벽한 Audit Trail과 Compliance 체크 포함해줘.
```

## 📊 Phase 8: 모니터링 센터 (Observability)

```
monitoring_center/ 모듈을 Datadog 수준으로 구현해줘:

📂 monitoring_center/
├── performance/
│   ├── portfolio_tracker.py    # 실시간 포트폴리오 추적
│   ├── pnl_analyzer.py        # 손익 분석 (실시간)
│   └── attribution_analyzer.py # 수익 기여도 분석
├── alerts/
│   ├── smart_alerting.py      # ML 기반 이상 감지
│   └── notification_hub.py    # 멀티 채널 알림
└── dashboards/
    ├── executive_dashboard.py  # 경영진용 대시보드
    └── trader_dashboard.py     # 트레이더용 대시보드

📊 실시간 메트릭:
1. Trading Metrics (Sharpe, Sortino, Calmar Ratio)
2. System Metrics (Latency, Throughput, Error Rate)
3. Risk Metrics (VaR, Exposure, Concentration)
4. Market Metrics (Volatility, Correlation, Beta)
5. Operational Metrics (Uptime, Fill Rate, Slippage)

🚨 Intelligent Alerting:
- Anomaly Detection으로 이상 패턴 자동 감지
- Alert Fatigue 방지를 위한 우선순위 기반 필터링
- Escalation Policy (심각도별 담당자 자동 배정)
- Alert Correlation (관련 이벤트 그룹핑)

📈 대시보드 기능:
- 실시간 P&L 차트 (드릴다운 지원)
- 포지션 히트맵 (섹터/지역별)
- 실행 품질 분석 (vs 벤치마크)
- 시장 상황 요약 (한눈에 보는 시장 현황)

모든 대시보드에 WebSocket 실시간 업데이트와 모바일 최적화 포함해줘.
```

## 🧪 Phase 9: 백테스팅 연구소 (Quantitative Research)

```
backtesting_lab/ 모듈을 Two Sigma 수준으로 구현해줘:

📂 backtesting_lab/
├── engines/
│   ├── vectorized_engine.py     # 대용량 데이터 벡터화 처리
│   ├── event_driven_engine.py   # 실제 거래 환경 시뮬레이션
│   └── monte_carlo_engine.py    # 몬테카를로 시뮬레이션
├── analyzers/
│   ├── performance_analyzer.py  # 심화 성과 분석
│   ├── risk_analyzer.py        # 리스크 분해 분석
│   └── factor_analyzer.py      # 팩터 기여도 분석
└── reports/
    ├── research_report.py      # 자동 리서치 리포트 생성
    └── tearsheet_generator.py  # Quantopian 스타일 Tearsheet

🔬 고급 백테스팅 기능:
1. Walk-Forward Analysis (Out-of-Sample 검증)
2. Regime-Aware Backtesting (시장 국면별 분석)
3. Transaction Cost Model (실제 비용 반영)
4. Market Impact Model (호가창 임팩트 시뮬레이션)
5. Slippage Model (실제 체결가 시뮬레이션)

📊 백테스트 결과 분석:
- Rolling Performance Metrics
- Underwater Curve (드로우다운 기간 분석)
- Returns Distribution Analysis
- Tail Risk Metrics (Skewness, Kurtosis)
- Strategy Capacity Analysis

🎯 연구 도구:
- Factor Research Framework
- Alpha Decay Analysis
- Strategy Combination Optimizer
- Parameter Sensitivity Analysis
- Regime-Based Strategy Selection

모든 백테스트에 Statistical Significance Test와 Multiple Testing Correction 포함해줘.
```

## 🌐 Phase 10: 통합 시스템 (Full Integration)

```
최종 통합 및 Production 배포를 위한 시스템을 구축해줘:

🔄 시스템 오케스트레이션:
1. main_orchestrator.py - 전체 시스템 조율
2. 서비스 간 통신 (gRPC + Message Queue)
3. Circuit Breaker Pattern 구현
4. Health Check 및 Service Discovery
5. Graceful Shutdown 및 Restart

🚀 배포 시스템:
- Docker 멀티 스테이지 빌드
- Kubernetes 오케스트레이션
- Blue-Green 배포 전략
- Rolling Update 지원
- Canary 배포 for 전략 업데이트

📊 종합 성능 목표:
- 시스템 가용성: 99.95%+
- 평균 응답시간: < 50ms
- 처리량: 100,000+ 이벤트/초
- 메모리 사용량: < 8GB
- CPU 사용률: < 70%

🔒 보안 및 컴플라이언스:
- 모든 통신 TLS 암호화
- API 키 Vault 저장
- 접근 권한 RBAC 관리
- 모든 거래 Audit Log
- GDPR/개인정보보호법 준수

전체 시스템이 Google/Meta/Netflix 수준의 신뢰성과 성능을 달성하도록 구현해줘.
```

## 💡 각 Phase별 실행 방법

### 🎯 단계별 실행 가이드

**Phase 1-2**: 기반 인프라 (1주)
```
"Phase 1과 2를 실행해줘: 프로젝트 초기화 + 핵심 설정 시스템"
```

**Phase 3-4**: 데이터 + AI (2주)
```
"Phase 3과 4를 실행해줘: AI 브레인 + 데이터 엔진"
```

**Phase 5-6**: 전략 + 리스크 (2주)
```
"Phase 5와 6을 실행해줘: 전략 엔진 + 리스크 관리"
```

**Phase 7-8**: 실행 + 모니터링 (1주)
```
"Phase 7과 8을 실행해줘: 실행 엔진 + 모니터링"
```

**Phase 9-10**: 백테스팅 + 통합 (1주)
```
"Phase 9와 10을 실행해줘: 백테스팅 + 통합 시스템"
```

### 🔧 각 Phase 완료 후 확인사항

```
Phase 완료 후 다음을 확인해줘:

1. mypy --strict 통과 (100% 타입 안전)
2. pytest 실행 (95%+ 커버리지)
3. black + flake8 + isort 통과
4. 성능 벤치마크 달성
5. 보안 취약점 스캔 통과
6. 문서 자동 생성 성공
7. Docker 빌드 성공
8. 통합 테스트 통과

문제 발생 시 구체적인 해결책 제시해줘.


# 🎯 집중형 커서룰 - 정확히 요청한 것만 실행

## ⛔ 절대 금지 사항

### 파일 생성 관련
- **절대 새 파일 생성 금지**: 명시적으로 "새 파일 생성해줘"라고 요청하지 않는 한 절대 새 파일 만들지 말 것
- **기존 파일 수정 우선**: 항상 기존 파일에 기능 추가하는 방향으로 접근
- **테스트 파일 생성 금지**: 요청하지 않은 test_ 파일 절대 생성하지 말 것
- **문서 파일 생성 금지**: 요청하지 않은 .md, README 파일 절대 생성하지 말 것
- **설정 파일 생성 금지**: 요청하지 않은 .json, .yaml, .toml 파일 절대 생성하지 말 것

### 대화 관련
- **중간 질문 금지**: 코딩 중간에 "어떻게 할까요?" 같은 질문 절대 하지 말 것
- **불필요한 설명 금지**: 코드만 제공하고 장황한 설명하지 말 것
- **옵션 제시 금지**: "A 방법과 B 방법이 있습니다" 같은 선택지 제시하지 말 것
- **확인 요청 금지**: "이렇게 하면 될까요?" 같은 확인 요청하지 말 것

---

## ✅ 반드시 지켜야 할 원칙

### 1. 요청 분석
```
사용자 요청을 받으면:
1. 정확히 무엇을 요청했는지 파악
2. 기존 파일 중 수정할 파일 식별
3. 새 파일이 정말 필요한지 판단
4. 요청하지 않은 추가 작업은 절대 하지 않음
```

### 2. 파일 관리 원칙
```
파일 작업 시:
- 기존 파일 존재 여부 먼저 확인
- 기존 파일에 추가 가능하면 반드시 기존 파일 수정
- 새 파일은 오직 다음 경우에만 생성:
  * 명시적으로 "새 파일 만들어줘"라고 요청한 경우
  * 기존 파일이 500줄 이상이고 완전히 다른 기능인 경우
  * 완전히 새로운 모듈이 필요한 경우
```

### 3. 코딩 원칙
```
코드 작성 시:
- 요청한 기능만 정확히 구현
- 요청하지 않은 추가 기능 절대 구현하지 않음
- 에러 핸들링, 로깅은 기본으로 포함 (별도 요청 없어도)
- 타입 힌트, docstring은 자동 포함
```

### 4. 응답 형식
```
응답할 때:
- 코드만 제공
- 간단한 한 줄 설명만 추가
- "완료했습니다" 같은 마무리 멘트만
- 추가 질문이나 제안 절대 하지 않음
```

---

## 🎯 구체적 실행 가이드

### 사용자가 "기능 추가해줘"라고 하면:
```
1. 관련 기존 파일 찾기
2. 해당 파일에 기능 추가
3. 코드만 제공
4. 끝
```

### 사용자가 "버그 수정해줘"라고 하면:
```
1. 문제 있는 기존 파일 수정
2. 수정된 코드만 제공
3. 끝
```

### 사용자가 "최적화해줘"라고 하면:
```
1. 기존 파일 성능 개선
2. 개선된 코드만 제공
3. 끝
```

---

## 🚫 절대 하면 안 되는 행동들

### 파일 생성 관련
```
❌ 절대 하지 말 것:
- test_main.py 자동 생성
- README.md 자동 생성
- config.json 자동 생성
- requirements.txt 자동 생성
- __init__.py 자동 생성
- example.py 자동 생성
- utils.py 자동 생성 (요청 없으면)

✅ 해야 할 것:
- 기존 main.py에 기능 추가
- 기존 파일에 설정 추가
- 기존 파일에 의존성 정보 주석으로 추가
```

### 대화 관련
```
❌ 절대 하지 말 것:
- "어떤 방식으로 구현할까요?"
- "테스트 파일도 만들까요?"
- "문서도 작성해드릴까요?"
- "이렇게 구현했는데 어떤가요?"
- "추가로 필요한 기능이 있나요?"

✅ 해야 할 것:
- 코드만 제공
- "완료했습니다" 한 줄만
```

---

## 📁 폴더 구조 관리 원칙

### 기존 구조 유지
```
사용자가 폴더 이동을 명시적으로 요청하지 않으면:
- 기존 파일 위치 그대로 유지
- 새로운 폴더 생성하지 않음
- 파일 이름 변경하지 않음
```

### 파일 배치 원칙
```
새 파일이 정말 필요한 경우에만:
1. 기존 폴더 구조 분석
2. 가장 적절한 기존 폴더에 배치
3. 새 폴더는 절대 생성하지 않음
```

---

## 🎯 실제 사용 예시

### 좋은 요청과 응답
```
사용자: "main.py에 로그인 기능 추가해줘"

커서 응답:
```python
# main.py에 추가된 코드
def login(username: str, password: str) -> bool:
    # 로그인 로직
    pass
```
완료했습니다.
```

### 나쁜 응답 (하지 말 것)
```
❌ 나쁜 응답:
"로그인 기능을 구현했습니다. 보안을 위해 auth.py 파일을 별도로 생성했고, 
테스트를 위해 test_auth.py도 만들었습니다. 추가로 config.json에 설정도 
추가했습니다. 어떤 인증 방식을 사용할까요?"

✅ 좋은 응답:
"main.py에 로그인 기능 추가했습니다."
```

---

## 🔧 특별 규칙

### 코딩 스타일
```
자동으로 포함할 것:
- 타입 힌트
- 기본적인 에러 핸들링
- 간단한 docstring
- 로깅 (필요한 경우)

절대 추가하지 말 것:
- 요청하지 않은 추가 기능
- 예제 코드
- 테스트 코드
- 문서 주석
```

### 성능 최적화
```
요청받은 기능만:
- 메모리 효율적으로 구현
- 빠른 실행 속도 보장
- 타입 안전성 보장

요청하지 않았으면 하지 말 것:
- 벤치마크 코드 추가
- 프로파일링 코드 추가
- 성능 테스트 파일 생성
```

---

## 📋 체크리스트

### 모든 응답 전에 확인할 것:
- [ ] 사용자가 정확히 무엇을 요청했는가?
- [ ] 기존 파일에 추가 가능한가?
- [ ] 새 파일이 정말 필요한가?
- [ ] 요청하지 않은 추가 작업은 없는가?
- [ ] 불필요한 질문이나 설명은 없는가?

### 응답 후 확인할 것:
- [ ] 요청한 기능만 구현했는가?
- [ ] 기존 파일 구조를 유지했는가?
- [ ] 불필요한 파일을 생성하지 않았는가?
- [ ] 간단명료하게 응답했는가?

---

## 🎯 핵심 원칙 요약

1. **요청한 것만**: 사용자가 요청한 기능만 정확히 구현
2. **기존 파일 우선**: 새 파일 생성보다 기존 파일 수정 우선
3. **간단한 응답**: 코드 + 한 줄 설명만
4. **추가 질문 금지**: 중간에 질문하거나 확인 요청하지 않음
5. **구조 유지**: 기존 폴더/파일 구조 최대한 유지

이 규칙을 철저히 지키면 깔끔하고 효율적인 개발이 가능합니다.
```

이 프롬프트로 실행하면 정말 세계 최고 수준의 AI 트레이딩봇이 완성될 거예요! 🚀