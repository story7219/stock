"""
üìä Ï∞®Ìä∏ Î∂ÑÏÑù Î∞è Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± ÌÅ¥ÎûòÏä§ (Gemini API Ìò∏Ìôò)
- Ï∫îÎì§Ïä§Ìã± Ï∞®Ìä∏ ÏÉùÏÑ± (mplfinance)
- Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ (Ïù¥ÎèôÌèâÍ∑†ÏÑ†, ÏùºÎ™©Í∑†ÌòïÌëú, RSI, MACD)
- Ï∞®Ìä∏ Ìå®ÌÑ¥ Í∞êÏßÄ (Ìó§ÎìúÏï§ÏàÑÎçî, ÏÇºÍ∞ÅÌòï, ÏåçÎ∞îÎã•/ÏåçÏ≤úÏ†ï)
- ÏßÄÏßÄ/Ï†ÄÌï≠ÏÑ† ÏûêÎèô Í≥ÑÏÇ∞
- base64 Ïù∏ÏΩîÎî©ÏúºÎ°ú Gemini API Ìò∏Ìôò
"""
import matplotlib.pyplot as plt
import mplfinance as mpf
import pandas as pd
import numpy as np
import yfinance as yf
from datetime import datetime, timedelta
import base64
import io
import logging
from typing import Dict, List, Tuple, Optional, Any
import requests
from dataclasses import dataclass
import warnings
import os # ÌååÏùº Ï†ÄÏû•ÏùÑ ÏúÑÌï¥ Ï∂îÍ∞Ä
warnings.filterwarnings('ignore')

# ÌïúÍ∏Ä Ìè∞Ìä∏ ÏÑ§Ï†ï
plt.rcParams['font.family'] = ['Malgun Gothic', 'DejaVu Sans']
plt.rcParams['axes.unicode_minus'] = False

logger = logging.getLogger(__name__)

@dataclass
class TechnicalIndicators:
    """Í∏∞Ïà†Ï†Å ÏßÄÌëú Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    sma_5: np.ndarray = None      # 5Ïùº Ïù¥ÎèôÌèâÍ∑†
    sma_20: np.ndarray = None     # 20Ïùº Ïù¥ÎèôÌèâÍ∑†
    sma_60: np.ndarray = None     # 60Ïùº Ïù¥ÎèôÌèâÍ∑†
    ema_12: np.ndarray = None     # 12Ïùº ÏßÄÏàòÏù¥ÎèôÌèâÍ∑†
    ema_26: np.ndarray = None     # 26Ïùº ÏßÄÏàòÏù¥ÎèôÌèâÍ∑†
    
    # ÏùºÎ™©Í∑†ÌòïÌëú
    tenkan_sen: np.ndarray = None  # Ï†ÑÌôòÏÑ†
    kijun_sen: np.ndarray = None   # Í∏∞Ï§ÄÏÑ†
    senkou_span_a: np.ndarray = None  # ÏÑ†ÌñâÏä§Ìå¨A
    senkou_span_b: np.ndarray = None  # ÏÑ†ÌñâÏä§Ìå¨B
    chikou_span: np.ndarray = None    # ÌõÑÌñâÏä§Ìå¨
    
    # Î™®Î©òÌÖÄ ÏßÄÌëú
    rsi: np.ndarray = None        # RSI
    macd: np.ndarray = None       # MACD
    macd_signal: np.ndarray = None # MACD ÏãúÍ∑∏ÎÑê
    macd_histogram: np.ndarray = None # MACD ÌûàÏä§ÌÜ†Í∑∏Îû®
    
    # Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú
    bb_upper: np.ndarray = None   # ÏÉÅÎã®Î∞¥Îìú
    bb_middle: np.ndarray = None  # Ï§ëÍ∞ÑÎ∞¥Îìú
    bb_lower: np.ndarray = None   # ÌïòÎã®Î∞¥Îìú

@dataclass
class ChartPattern:
    """Ï∞®Ìä∏ Ìå®ÌÑ¥ Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    pattern_type: str             # Ìå®ÌÑ¥ Ïú†Ìòï
    confidence: float             # Ïã†Î¢∞ÎèÑ (0-1)
    start_idx: int               # ÏãúÏûë Ïù∏Îç±Ïä§
    end_idx: int                 # Ï¢ÖÎ£å Ïù∏Îç±Ïä§
    target_price: float = None   # Î™©ÌëúÍ∞Ä
    stop_loss: float = None      # ÏÜêÏ†àÍ∞Ä
    description: str = ""        # Ìå®ÌÑ¥ ÏÑ§Î™Ö

@dataclass
class SupportResistance:
    """ÏßÄÏßÄ/Ï†ÄÌï≠ÏÑ† Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    support_levels: List[float]   # ÏßÄÏßÄÏÑ† Î†àÎ≤®Îì§
    resistance_levels: List[float] # Ï†ÄÌï≠ÏÑ† Î†àÎ≤®Îì§
    current_trend: str           # ÌòÑÏû¨ Ï∂îÏÑ∏ (ÏÉÅÏäπ/ÌïòÎùΩ/Ìö°Î≥¥)
    strength_scores: Dict[float, float] # Í∞Å Î†àÎ≤®Ïùò Í∞ïÎèÑ

class ChartManager:
    """üìä Ï∞®Ìä∏ Î∂ÑÏÑù Î∞è Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, kis_api_key: str = None, kis_secret: str = None, trader_instance=None):
        """ChartManager Ï¥àÍ∏∞Ìôî"""
        self.kis_api_key = kis_api_key
        self.kis_secret = kis_secret
        self.trader = trader_instance # CoreTrader Ïù∏Ïä§ÌÑ¥Ïä§
        
        # ÌïúÍµ≠Ìà¨ÏûêÏ¶ùÍ∂å API ÏÑ§Ï†ï
        self.base_url = "https://openapi.koreainvestment.com:9443"
        self.session = requests.Session()
        
        # Ï∞®Ìä∏ Ï†ÄÏû• Í≤ΩÎ°ú
        self.chart_dir = "charts"
        os.makedirs(self.chart_dir, exist_ok=True)
        
        # Ï∞®Ìä∏ Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
        self.chart_style = {
            'figsize': (12, 8),
            'volume': True,
            'mav': (5, 20, 60),  # Ïù¥ÎèôÌèâÍ∑†ÏÑ†
            'style': 'charles',   # Ï∞®Ìä∏ Ïä§ÌÉÄÏùº
            'marketcolors': mpf.make_marketcolors(
                up='red', down='blue',  # ÌïúÍµ≠Ïãù ÏÉâÏÉÅ
                edge='inherit',
                wick={'up': 'red', 'down': 'blue'},
                volume='in'
            )
        }
        
        logger.info("üìä ChartManager Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    def get_stock_data(self, stock_code: str, period: str = '1D') -> pd.DataFrame:
        """Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ ÏàòÏßë"""
        try:
            # Í∏∞Í∞Ñ ÏÑ§Ï†ï
            period_map = {
                '1D': 1,    # 1Ïùº
                '1W': 7,    # 1Ï£º
                '1M': 30,   # 1Í∞úÏõî
                '3M': 90,   # 3Í∞úÏõî
                '6M': 180,  # 6Í∞úÏõî
                '1Y': 365   # 1ÎÖÑ
            }
            
            days = period_map.get(period, 30)
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days + 50)  # ÏßÄÌëú Í≥ÑÏÇ∞ÏùÑ ÏúÑÌïú Ï∂îÍ∞Ä Îç∞Ïù¥ÌÑ∞
            
            # yfinanceÎ•º ÏÇ¨Ïö©Ìïú Îç∞Ïù¥ÌÑ∞ ÏàòÏßë (ÌïúÍµ≠ Ï£ºÏãù)
            ticker = f"{stock_code}.KS"
            if stock_code.startswith('A'):  # ÏΩîÏä§Îã•
                ticker = f"{stock_code[1:]}.KQ"
            elif len(stock_code) == 6:  # ÌëúÏ§Ä 6ÏûêÎ¶¨ ÏΩîÎìú
                ticker = f"{stock_code}.KS"
            
            stock = yf.Ticker(ticker)
            df = stock.history(start=start_date, end=end_date)
            
            if df.empty:
                # ÎåÄÏ≤¥ Î∞©Î≤ï: ÏÉòÌîå Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                df = self._generate_sample_data(stock_code, days)
            
            # Ïª¨ÎüºÎ™Ö ÌëúÏ§ÄÌôî
            df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
            df = df.dropna()
            
            # ÏµúÍ∑º Í∏∞Í∞ÑÎßå ÏÑ†ÌÉù
            df = df.tail(days)
            
            logger.info(f"üìä {stock_code} Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÏôÑÎ£å: {len(df)}Ïùº")
            return df
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®, ÏÉòÌîå Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±: {e}")
            return self._generate_sample_data(stock_code, days)
    
    def _generate_sample_data(self, stock_code: str, days: int) -> pd.DataFrame:
        """ÏÉòÌîå Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±"""
        np.random.seed(42)  # Ïû¨ÌòÑ Í∞ÄÎä•Ìïú ÎûúÎç§
        
        # Í∏∞Î≥∏ Í∞ÄÍ≤© ÏÑ§Ï†ï (Ï¢ÖÎ™©Î≥Ñ)
        base_prices = {
            '005930': 70000,   # ÏÇºÏÑ±Ï†ÑÏûê
            '000660': 120000,  # SKÌïòÏù¥ÎãâÏä§
            '035420': 180000,  # NAVER
            '051910': 400000,  # LGÌôîÌïô
        }
        
        base_price = base_prices.get(stock_code, 50000)
        
        # Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (ÌòÑÏã§Ï†ÅÏù∏ Ìå®ÌÑ¥)
        dates = pd.date_range(end=datetime.now(), periods=days, freq='D')
        
        # Ìä∏Î†åÎìúÏôÄ Î≥ÄÎèôÏÑ± Ï†ÅÏö©
        trend = np.random.choice([-0.001, 0, 0.001], size=days, p=[0.3, 0.4, 0.3])
        volatility = 0.02  # 2% ÏùºÏùº Î≥ÄÎèôÏÑ±
        
        returns = np.random.normal(trend, volatility, days)
        prices = [base_price]
        
        for r in returns[1:]:
            new_price = prices[-1] * (1 + r)
            prices.append(max(new_price, prices[-1] * 0.9))  # ÏµúÎåÄ 10% ÌïòÎùΩ Ï†úÌïú
        
        # OHLC Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
        data = []
        for i, price in enumerate(prices):
            high = price * (1 + abs(np.random.normal(0, 0.01)))
            low = price * (1 - abs(np.random.normal(0, 0.01)))
            open_price = prices[i-1] if i > 0 else price
            close_price = price
            volume = np.random.randint(100000, 1000000)
            
            data.append([open_price, high, low, close_price, volume])
        
        df = pd.DataFrame(data, columns=['Open', 'High', 'Low', 'Close', 'Volume'])
        df.index = dates
        
        return df
    
    # === Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ (Numpy Íµ¨ÌòÑ) ===
    
    def _calculate_sma(self, data: np.ndarray, period: int) -> np.ndarray:
        """Îã®ÏàúÏù¥ÎèôÌèâÍ∑† Í≥ÑÏÇ∞"""
        sma = np.full_like(data, np.nan)
        for i in range(period-1, len(data)):
            sma[i] = np.mean(data[i-period+1:i+1])
        return sma
    
    def _calculate_ema(self, data: np.ndarray, period: int) -> np.ndarray:
        """ÏßÄÏàòÏù¥ÎèôÌèâÍ∑† Í≥ÑÏÇ∞"""
        ema = np.full_like(data, np.nan)
        alpha = 2.0 / (period + 1)
        
        # Ï≤´ Î≤àÏß∏ Í∞íÏùÄ SMAÎ°ú ÏãúÏûë
        ema[period-1] = np.mean(data[:period])
        
        # EMA Í≥ÑÏÇ∞
        for i in range(period, len(data)):
            ema[i] = alpha * data[i] + (1 - alpha) * ema[i-1]
        
        return ema
    
    def _calculate_rsi(self, close: np.ndarray, period: int = 14) -> np.ndarray:
        """RSI Í≥ÑÏÇ∞"""
        rsi = np.full_like(close, np.nan)
        
        # Í∞ÄÍ≤© Î≥ÄÌôî Í≥ÑÏÇ∞
        delta = np.diff(close, prepend=close[0])
        
        # ÏÉÅÏäπ/ÌïòÎùΩ Î∂ÑÎ¶¨
        gains = np.where(delta > 0, delta, 0)
        losses = np.where(delta < 0, -delta, 0)
        
        # ÌèâÍ∑† ÏÉÅÏäπ/ÌïòÎùΩ Í≥ÑÏÇ∞
        avg_gains = np.full_like(close, np.nan)
        avg_losses = np.full_like(close, np.nan)
        
        # Ï¥àÍ∏∞ ÌèâÍ∑† Í≥ÑÏÇ∞
        if len(gains) >= period:
            avg_gains[period] = np.mean(gains[1:period+1])
            avg_losses[period] = np.mean(losses[1:period+1])
            
            # RSI Í≥ÑÏÇ∞
            for i in range(period+1, len(close)):
                avg_gains[i] = (avg_gains[i-1] * (period-1) + gains[i]) / period
                avg_losses[i] = (avg_losses[i-1] * (period-1) + losses[i]) / period
                
                if avg_losses[i] != 0:
                    rs = avg_gains[i] / avg_losses[i]
                    rsi[i] = 100 - (100 / (1 + rs))
                else:
                    rsi[i] = 100
        
        return rsi
    
    def _calculate_macd(self, close: np.ndarray, fast: int = 12, slow: int = 26, signal: int = 9) -> tuple:
        """MACD Í≥ÑÏÇ∞"""
        ema_fast = self._calculate_ema(close, fast)
        ema_slow = self._calculate_ema(close, slow)
        
        macd = ema_fast - ema_slow
        macd_signal = self._calculate_ema(macd[~np.isnan(macd)], signal)
        
        # Ïã†Ìò∏ÏÑ† Í∏∏Ïù¥ ÎßûÏ∂îÍ∏∞
        signal_full = np.full_like(macd, np.nan)
        valid_idx = ~np.isnan(macd)
        signal_full[valid_idx] = np.pad(macd_signal, (np.sum(valid_idx) - len(macd_signal), 0), 
                                       mode='constant', constant_values=np.nan)[:np.sum(valid_idx)]
        
        macd_histogram = macd - signal_full
        
        return macd, signal_full, macd_histogram
    
    def _calculate_bollinger_bands(self, close: np.ndarray, period: int = 20, std_dev: float = 2) -> tuple:
        """Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú Í≥ÑÏÇ∞"""
        middle = self._calculate_sma(close, period)
        
        # ÌëúÏ§ÄÌé∏Ï∞® Í≥ÑÏÇ∞
        std = np.full_like(close, np.nan)
        for i in range(period-1, len(close)):
            std[i] = np.std(close[i-period+1:i+1])
        
        upper = middle + (std * std_dev)
        lower = middle - (std * std_dev)
        
        return upper, middle, lower

    def calculate_technical_indicators(self, stock_code: str, period: str = '1M') -> TechnicalIndicators:
        """üìà Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞"""
        try:
            # Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            df = self.get_stock_data(stock_code, period)
            
            if len(df) < 60:
                logger.warning(f"‚ö†Ô∏è Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±: {len(df)}Ïùº (ÏµúÏÜå 60Ïùº ÌïÑÏöî)")
                return TechnicalIndicators()
            
            high = df['High'].values
            low = df['Low'].values
            close = df['Close'].values
            volume = df['Volume'].values
            
            indicators = TechnicalIndicators()
            
            # Ïù¥ÎèôÌèâÍ∑†ÏÑ†
            indicators.sma_5 = self._calculate_sma(close, 5)
            indicators.sma_20 = self._calculate_sma(close, 20)
            indicators.sma_60 = self._calculate_sma(close, 60)
            
            # ÏßÄÏàòÏù¥ÎèôÌèâÍ∑†ÏÑ†
            indicators.ema_12 = self._calculate_ema(close, 12)
            indicators.ema_26 = self._calculate_ema(close, 26)
            
            # ÏùºÎ™©Í∑†ÌòïÌëú
            indicators.tenkan_sen = self._calculate_tenkan_sen(high, low)
            indicators.kijun_sen = self._calculate_kijun_sen(high, low)
            indicators.senkou_span_a = self._calculate_senkou_span_a(indicators.tenkan_sen, indicators.kijun_sen)
            indicators.senkou_span_b = self._calculate_senkou_span_b(high, low)
            indicators.chikou_span = np.roll(close, -26)  # 26Ïùº ÌõÑÌñâ
            
            # RSI
            indicators.rsi = self._calculate_rsi(close, 14)
            
            # MACD
            indicators.macd, indicators.macd_signal, indicators.macd_histogram = self._calculate_macd(close)
            
            # Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú
            indicators.bb_upper, indicators.bb_middle, indicators.bb_lower = self._calculate_bollinger_bands(close)
            
            logger.info(f"üìà {stock_code} Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ ÏôÑÎ£å")
            return indicators
            
        except Exception as e:
            logger.error(f"‚ùå Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return TechnicalIndicators()
    
    def _calculate_tenkan_sen(self, high: np.ndarray, low: np.ndarray, period: int = 9) -> np.ndarray:
        """Ï†ÑÌôòÏÑ† Í≥ÑÏÇ∞ (9Ïùº)"""
        tenkan = np.full_like(high, np.nan)
        for i in range(period-1, len(high)):
            period_high = np.max(high[i-period+1:i+1])
            period_low = np.min(low[i-period+1:i+1])
            tenkan[i] = (period_high + period_low) / 2
        return tenkan
    
    def _calculate_kijun_sen(self, high: np.ndarray, low: np.ndarray, period: int = 26) -> np.ndarray:
        """Í∏∞Ï§ÄÏÑ† Í≥ÑÏÇ∞ (26Ïùº)"""
        kijun = np.full_like(high, np.nan)
        for i in range(period-1, len(high)):
            period_high = np.max(high[i-period+1:i+1])
            period_low = np.min(low[i-period+1:i+1])
            kijun[i] = (period_high + period_low) / 2
        return kijun
    
    def _calculate_senkou_span_a(self, tenkan: np.ndarray, kijun: np.ndarray) -> np.ndarray:
        """ÏÑ†ÌñâÏä§Ìå¨A Í≥ÑÏÇ∞"""
        span_a = (tenkan + kijun) / 2
        return np.roll(span_a, 26)  # 26Ïùº ÏÑ†Ìñâ
    
    def _calculate_senkou_span_b(self, high: np.ndarray, low: np.ndarray, period: int = 52) -> np.ndarray:
        """ÏÑ†ÌñâÏä§Ìå¨B Í≥ÑÏÇ∞ (52Ïùº)"""
        span_b = np.full_like(high, np.nan)
        for i in range(period-1, len(high)):
            period_high = np.max(high[i-period+1:i+1])
            period_low = np.min(low[i-period+1:i+1])
            span_b[i] = (period_high + period_low) / 2
        return np.roll(span_b, 26)  # 26Ïùº ÏÑ†Ìñâ
    
    def detect_patterns(self, stock_code: str, period: str = '3M') -> List[ChartPattern]:
        """üîç Ï∞®Ìä∏ Ìå®ÌÑ¥ Í∞êÏßÄ"""
        try:
            df = self.get_stock_data(stock_code, period)
            patterns = []
            
            if len(df) < 30:
                return patterns
            
            close = df['Close'].values
            high = df['High'].values
            low = df['Low'].values
            
            # 1. Ìó§ÎìúÏï§ÏàÑÎçî Ìå®ÌÑ¥ Í∞êÏßÄ
            head_shoulder = self._detect_head_and_shoulders(high, low, close)
            if head_shoulder:
                patterns.append(head_shoulder)
            
            # 2. ÏåçÎ∞îÎã•/ÏåçÏ≤úÏ†ï Ìå®ÌÑ¥ Í∞êÏßÄ
            double_patterns = self._detect_double_patterns(high, low, close)
            patterns.extend(double_patterns)
            
            # 3. ÏÇºÍ∞ÅÌòï Ìå®ÌÑ¥ Í∞êÏßÄ
            triangle = self._detect_triangle_pattern(high, low)
            if triangle:
                patterns.append(triangle)
            
            # 4. ÏÉÅÏäπ/ÌïòÎùΩ Ïõ®ÏßÄ Ìå®ÌÑ¥
            wedge = self._detect_wedge_pattern(high, low, close)
            if wedge:
                patterns.append(wedge)
            
            # 5. ÌîåÎûòÍ∑∏/ÌéòÎÑåÌä∏ Ìå®ÌÑ¥
            flag = self._detect_flag_pattern(close)
            if flag:
                patterns.append(flag)
            
            logger.info(f"üîç {stock_code} Ìå®ÌÑ¥ Í∞êÏßÄ ÏôÑÎ£å: {len(patterns)}Í∞ú")
            return patterns
            
        except Exception as e:
            logger.error(f"‚ùå Ìå®ÌÑ¥ Í∞êÏßÄ Ïã§Ìå®: {e}")
            return []
    
    def _detect_head_and_shoulders(self, high: np.ndarray, low: np.ndarray, close: np.ndarray) -> Optional[ChartPattern]:
        """Ìó§ÎìúÏï§ÏàÑÎçî Ìå®ÌÑ¥ Í∞êÏßÄ"""
        if len(high) < 20:
            return None
        
        # Í∞ÑÎã®Ìïú Ìó§ÎìúÏï§ÏàÑÎçî Í∞êÏßÄ Î°úÏßÅ
        peaks = []
        for i in range(2, len(high)-2):
            if high[i] > high[i-1] and high[i] > high[i+1] and high[i] > high[i-2] and high[i] > high[i+2]:
                peaks.append((i, high[i]))
        
        if len(peaks) >= 3:
            # ÎßàÏßÄÎßâ 3Í∞ú ÌîºÌÅ¨ ÌôïÏù∏
            recent_peaks = peaks[-3:]
            left_shoulder, head, right_shoulder = recent_peaks
            
            # Ìó§ÎìúÏï§ÏàÑÎçî Ï°∞Í±¥ ÌôïÏù∏
            if (head[1] > left_shoulder[1] and head[1] > right_shoulder[1] and
                abs(left_shoulder[1] - right_shoulder[1]) / left_shoulder[1] < 0.05):  # 5% Ïò§Ï∞® ÌóàÏö©
                
                return ChartPattern(
                    pattern_type="Ìó§ÎìúÏï§ÏàÑÎçî",
                    confidence=0.7,
                    start_idx=left_shoulder[0],
                    end_idx=right_shoulder[0],
                    target_price=close[-1] * 0.9,  # 10% ÌïòÎùΩ Î™©Ìëú
                    description="Ìó§ÎìúÏï§ÏàÑÎçî Ìå®ÌÑ¥ Í∞êÏßÄ: ÌïòÎùΩ Ïã†Ìò∏"
                )
        
        return None
    
    def _detect_double_patterns(self, high: np.ndarray, low: np.ndarray, close: np.ndarray) -> List[ChartPattern]:
        """ÏåçÎ∞îÎã•/ÏåçÏ≤úÏ†ï Ìå®ÌÑ¥ Í∞êÏßÄ"""
        patterns = []
        
        # ÏåçÏ≤úÏ†ï Í∞êÏßÄ
        peaks = []
        for i in range(1, len(high)-1):
            if high[i] > high[i-1] and high[i] > high[i+1]:
                peaks.append((i, high[i]))
        
        for i in range(len(peaks)-1):
            peak1, peak2 = peaks[i], peaks[i+1]
            if (abs(peak1[1] - peak2[1]) / peak1[1] < 0.03 and  # 3% Ïò§Ï∞® ÌóàÏö©
                peak2[0] - peak1[0] >= 10):  # ÏµúÏÜå 10Ïùº Í∞ÑÍ≤©
                
                patterns.append(ChartPattern(
                    pattern_type="ÏåçÏ≤úÏ†ï",
                    confidence=0.6,
                    start_idx=peak1[0],
                    end_idx=peak2[0],
                    target_price=close[-1] * 0.92,
                    description="ÏåçÏ≤úÏ†ï Ìå®ÌÑ¥: ÌïòÎùΩ Ïã†Ìò∏"
                ))
                break
        
        # ÏåçÎ∞îÎã• Í∞êÏßÄ
        troughs = []
        for i in range(1, len(low)-1):
            if low[i] < low[i-1] and low[i] < low[i+1]:
                troughs.append((i, low[i]))
        
        for i in range(len(troughs)-1):
            trough1, trough2 = troughs[i], troughs[i+1]
            if (abs(trough1[1] - trough2[1]) / trough1[1] < 0.03 and
                trough2[0] - trough1[0] >= 10):
                
                patterns.append(ChartPattern(
                    pattern_type="ÏåçÎ∞îÎã•",
                    confidence=0.6,
                    start_idx=trough1[0],
                    end_idx=trough2[0],
                    target_price=close[-1] * 1.08,
                    description="ÏåçÎ∞îÎã• Ìå®ÌÑ¥: ÏÉÅÏäπ Ïã†Ìò∏"
                ))
                break
        
        return patterns
    
    def _detect_triangle_pattern(self, high: np.ndarray, low: np.ndarray) -> Optional[ChartPattern]:
        """ÏÇºÍ∞ÅÌòï Ìå®ÌÑ¥ Í∞êÏßÄ"""
        if len(high) < 20:
            return None
        
        # ÏµúÍ∑º 20Ïùº Îç∞Ïù¥ÌÑ∞Î°ú ÏÇºÍ∞ÅÌòï Ìå®ÌÑ¥ ÌôïÏù∏
        recent_high = high[-20:]
        recent_low = low[-20:]
        
        # Í≥†Ï†ê Ïó∞Í≤∞ÏÑ†Ïùò Í∏∞Ïö∏Í∏∞
        high_slope = np.polyfit(range(len(recent_high)), recent_high, 1)[0]
        # Ï†ÄÏ†ê Ïó∞Í≤∞ÏÑ†Ïùò Í∏∞Ïö∏Í∏∞
        low_slope = np.polyfit(range(len(recent_low)), recent_low, 1)[0]
        
        # ÏàòÎ†¥ ÏÇºÍ∞ÅÌòï (Í≥†Ï†êÏùÄ ÌïòÎùΩ, Ï†ÄÏ†êÏùÄ ÏÉÅÏäπ)
        if high_slope < -0.1 and low_slope > 0.1:
            return ChartPattern(
                pattern_type="ÏàòÎ†¥ÏÇºÍ∞ÅÌòï",
                confidence=0.5,
                start_idx=len(high)-20,
                end_idx=len(high)-1,
                description="ÏàòÎ†¥ÏÇºÍ∞ÅÌòï Ìå®ÌÑ¥: ÎèåÌåå ÎåÄÍ∏∞"
            )
        
        return None
    
    def _detect_wedge_pattern(self, high: np.ndarray, low: np.ndarray, close: np.ndarray) -> Optional[ChartPattern]:
        """Ïõ®ÏßÄ Ìå®ÌÑ¥ Í∞êÏßÄ"""
        if len(high) < 15:
            return None
        
        # ÏµúÍ∑º 15Ïùº Ï∂îÏÑ∏
        recent_trend = np.polyfit(range(15), close[-15:], 1)[0]
        high_trend = np.polyfit(range(15), high[-15:], 1)[0]
        low_trend = np.polyfit(range(15), low[-15:], 1)[0]
        
        # ÏÉÅÏäπ Ïõ®ÏßÄ (ÏÉÅÏäπ Ï∂îÏÑ∏ÏóêÏÑú Í≥†Ï†êÍ≥º Ï†ÄÏ†êÏù¥ Î™®Îëê ÏÉÅÏäπÌïòÏßÄÎßå Ìè≠Ïù¥ Ï¢ÅÏïÑÏßê)
        if (recent_trend > 0 and high_trend > 0 and low_trend > 0 and 
            high_trend < low_trend * 2):  # ÏàòÎ†¥ Ï°∞Í±¥
            
            return ChartPattern(
                pattern_type="ÏÉÅÏäπÏõ®ÏßÄ",
                confidence=0.4,
                start_idx=len(high)-15,
                end_idx=len(high)-1,
                target_price=close[-1] * 0.95,
                description="ÏÉÅÏäπÏõ®ÏßÄ Ìå®ÌÑ¥: Ï°∞Ï†ï Í∞ÄÎä•ÏÑ±"
            )
        
        return None
    
    def _detect_flag_pattern(self, close: np.ndarray) -> Optional[ChartPattern]:
        """ÌîåÎûòÍ∑∏ Ìå®ÌÑ¥ Í∞êÏßÄ"""
        if len(close) < 10:
            return None
        
        # ÏµúÍ∑º 10ÏùºÍ∞Ñ Ìö°Î≥¥ Ïó¨Î∂Ä ÌôïÏù∏
        recent_prices = close[-10:]
        volatility = np.std(recent_prices) / np.mean(recent_prices)
        
        # Î≥ÄÎèôÏÑ±Ïù¥ ÎÇÆÏúºÎ©¥ ÌîåÎûòÍ∑∏ Ìå®ÌÑ¥ÏúºÎ°ú Í∞ÑÏ£º
        if volatility < 0.02:  # 2% ÎØ∏Îßå Î≥ÄÎèôÏÑ±
            return ChartPattern(
                pattern_type="ÌîåÎûòÍ∑∏",
                confidence=0.3,
                start_idx=len(close)-10,
                end_idx=len(close)-1,
                description="ÌîåÎûòÍ∑∏ Ìå®ÌÑ¥: Ìö°Î≥¥ ÌõÑ ÎèåÌåå ÎåÄÍ∏∞"
            )
        
        return None
    
    def get_support_resistance(self, stock_code: str, period: str = '3M') -> SupportResistance:
        """üìä ÏßÄÏßÄ/Ï†ÄÌï≠ÏÑ† Í≥ÑÏÇ∞"""
        try:
            df = self.get_stock_data(stock_code, period)
            
            if len(df) < 20:
                return SupportResistance([], [], "Ìö°Î≥¥", {})
            
            high = df['High'].values
            low = df['Low'].values
            close = df['Close'].values
            
            # ÏßÄÏßÄÏÑ† Ï∞æÍ∏∞ (Ï†ÄÏ†êÎì§)
            support_levels = self._find_support_levels(low, close)
            
            # Ï†ÄÌï≠ÏÑ† Ï∞æÍ∏∞ (Í≥†Ï†êÎì§)
            resistance_levels = self._find_resistance_levels(high, close)
            
            # ÌòÑÏû¨ Ï∂îÏÑ∏ ÌåêÎã®
            current_trend = self._determine_trend(close)
            
            # Í∞Å Î†àÎ≤®Ïùò Í∞ïÎèÑ Í≥ÑÏÇ∞
            strength_scores = self._calculate_level_strength(
                support_levels + resistance_levels, high, low, close
            )
            
            logger.info(f"üìä {stock_code} ÏßÄÏßÄ/Ï†ÄÌï≠ÏÑ† Í≥ÑÏÇ∞ ÏôÑÎ£å")
            return SupportResistance(
                support_levels=support_levels,
                resistance_levels=resistance_levels,
                current_trend=current_trend,
                strength_scores=strength_scores
            )
            
        except Exception as e:
            logger.error(f"‚ùå ÏßÄÏßÄ/Ï†ÄÌï≠ÏÑ† Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return SupportResistance([], [], "Ìö°Î≥¥", {})
    
    def _find_support_levels(self, low: np.ndarray, close: np.ndarray) -> List[float]:
        """ÏßÄÏßÄÏÑ† Î†àÎ≤® Ï∞æÍ∏∞"""
        support_levels = []
        current_price = close[-1]
        
        # ÏµúÍ∑º Ï†ÄÏ†êÎì§ Ï∞æÍ∏∞
        for i in range(2, len(low)-2):
            if (low[i] < low[i-1] and low[i] < low[i+1] and 
                low[i] < low[i-2] and low[i] < low[i+2]):
                
                # ÌòÑÏû¨Í∞Ä ÏïÑÎûòÏóê ÏûàÎäî ÏßÄÏßÄÏÑ†Îßå ÏÑ†ÌÉù
                if low[i] < current_price * 0.98:  # 2% ÏïÑÎûò
                    support_levels.append(low[i])
        
        # Ï§ëÎ≥µ Ï†úÍ±∞ Î∞è Ï†ïÎ†¨
        support_levels = sorted(list(set([round(level, -1) for level in support_levels])))
        
        # ÏÉÅÏúÑ 3Í∞úÎßå ÏÑ†ÌÉù
        return support_levels[-3:] if len(support_levels) > 3 else support_levels
    
    def _find_resistance_levels(self, high: np.ndarray, close: np.ndarray) -> List[float]:
        """Ï†ÄÌï≠ÏÑ† Î†àÎ≤® Ï∞æÍ∏∞"""
        resistance_levels = []
        current_price = close[-1]
        
        # ÏµúÍ∑º Í≥†Ï†êÎì§ Ï∞æÍ∏∞
        for i in range(2, len(high)-2):
            if (high[i] > high[i-1] and high[i] > high[i+1] and 
                high[i] > high[i-2] and high[i] > high[i+2]):
                
                # ÌòÑÏû¨Í∞Ä ÏúÑÏóê ÏûàÎäî Ï†ÄÌï≠ÏÑ†Îßå ÏÑ†ÌÉù
                if high[i] > current_price * 1.02:  # 2% ÏúÑ
                    resistance_levels.append(high[i])
        
        # Ï§ëÎ≥µ Ï†úÍ±∞ Î∞è Ï†ïÎ†¨
        resistance_levels = sorted(list(set([round(level, -1) for level in resistance_levels])))
        
        # ÏÉÅÏúÑ 3Í∞úÎßå ÏÑ†ÌÉù
        return resistance_levels[:3] if len(resistance_levels) > 3 else resistance_levels
    
    def _determine_trend(self, close: np.ndarray) -> str:
        """ÌòÑÏû¨ Ï∂îÏÑ∏ ÌåêÎã®"""
        if len(close) < 20:
            return "Ìö°Î≥¥"
        
        # ÏµúÍ∑º 20Ïùº Ï∂îÏÑ∏ÏÑ†
        trend_slope = np.polyfit(range(20), close[-20:], 1)[0]
        
        # Ï∂îÏÑ∏ Í∞ïÎèÑ Í≥ÑÏÇ∞
        price_change = (close[-1] - close[-20]) / close[-20]
        
        if trend_slope > 0 and price_change > 0.05:  # 5% Ïù¥ÏÉÅ ÏÉÅÏäπ
            return "ÏÉÅÏäπ"
        elif trend_slope < 0 and price_change < -0.05:  # 5% Ïù¥ÏÉÅ ÌïòÎùΩ
            return "ÌïòÎùΩ"
        else:
            return "Ìö°Î≥¥"
    
    def _calculate_level_strength(self, levels: List[float], high: np.ndarray, 
                                 low: np.ndarray, close: np.ndarray) -> Dict[float, float]:
        """ÏßÄÏßÄ/Ï†ÄÌï≠ÏÑ† Í∞ïÎèÑ Í≥ÑÏÇ∞"""
        strength_scores = {}
        
        for level in levels:
            touches = 0
            
            # Ìï¥Îãπ Î†àÎ≤® Í∑ºÏ≤òÏóêÏÑúÏùò ÌÑ∞Ïπò ÌöüÏàò Í≥ÑÏÇ∞
            for i in range(len(close)):
                price_range = abs(high[i] - low[i])
                tolerance = price_range * 0.5  # Î≤îÏúÑÏùò 50%Î•º ÌóàÏö© Ïò§Ï∞®Î°ú
                
                if abs(high[i] - level) <= tolerance or abs(low[i] - level) <= tolerance:
                    touches += 1
            
            # ÌÑ∞Ïπò ÌöüÏàòÏóê Îî∞Î•∏ Í∞ïÎèÑ Í≥ÑÏÇ∞ (0-1 Ïä§ÏºÄÏùº)
            strength_scores[level] = min(touches / 5.0, 1.0)  # ÏµúÎåÄ 5Ìöå ÌÑ∞ÏπòÎ•º 1.0ÏúºÎ°ú
        
        return strength_scores
    
    def generate_chart_image(self, stock_code: str, period: str = '1D') -> str:
        """üìä Ï∞®Ìä∏ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Î∞è base64 Ïù∏ÏΩîÎî©"""
        try:
            # Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ Î∞è ÏßÄÌëú ÏàòÏßë
            df = self.get_stock_data(stock_code, period)
            indicators = self.calculate_technical_indicators(stock_code, period)
            patterns = self.detect_patterns(stock_code, period)
            support_resistance = self.get_support_resistance(stock_code, period)
            
            if len(df) < 5:
                raise ValueError("Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±")
            
            # Ï∞®Ìä∏ ÏÉùÏÑ±ÏùÑ ÏúÑÌïú Ï∂îÍ∞Ä ÏÑ§Ï†ï
            additional_plots = []
            
            # Ïù¥ÎèôÌèâÍ∑†ÏÑ† Ï∂îÍ∞Ä
            if indicators.sma_5 is not None:
                additional_plots.append(
                    mpf.make_addplot(indicators.sma_5, color='orange', width=1, label='SMA5')
                )
            if indicators.sma_20 is not None:
                additional_plots.append(
                    mpf.make_addplot(indicators.sma_20, color='blue', width=1, label='SMA20')
                )
            if indicators.sma_60 is not None:
                additional_plots.append(
                    mpf.make_addplot(indicators.sma_60, color='purple', width=1, label='SMA60')
                )
            
            # ÏùºÎ™©Í∑†ÌòïÌëú Íµ¨Î¶ÑÎåÄ (ÏÑ†ÌñâÏä§Ìå¨A, B)
            if indicators.senkou_span_a is not None and indicators.senkou_span_b is not None:
                # Íµ¨Î¶ÑÎåÄ ÏòÅÏó≠ ÌëúÏãúÎ•º ÏúÑÌïú fill_between Ìö®Í≥º
                cloud_data = pd.DataFrame({
                    'span_a': indicators.senkou_span_a,
                    'span_b': indicators.senkou_span_b
                }, index=df.index)
                
                additional_plots.append(
                    mpf.make_addplot(indicators.senkou_span_a, color='green', 
                                   width=0.5, alpha=0.3, label='ÏÑ†ÌñâÏä§Ìå¨A')
                )
                additional_plots.append(
                    mpf.make_addplot(indicators.senkou_span_b, color='red', 
                                   width=0.5, alpha=0.3, label='ÏÑ†ÌñâÏä§Ìå¨B')
                )
            
            # Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú
            if indicators.bb_upper is not None:
                additional_plots.append(
                    mpf.make_addplot(indicators.bb_upper, color='gray', 
                                   width=0.5, alpha=0.7, label='Î≥ºÎ¶∞Ï†Ä ÏÉÅÎã®')
                )
                additional_plots.append(
                    mpf.make_addplot(indicators.bb_lower, color='gray', 
                                   width=0.5, alpha=0.7, label='Î≥ºÎ¶∞Ï†Ä ÌïòÎã®')
                )
            
            # ÏßÄÏßÄ/Ï†ÄÌï≠ÏÑ† Ï∂îÍ∞Ä
            current_price = df['Close'].iloc[-1]
            for level in support_resistance.support_levels:
                if abs(level - current_price) / current_price < 0.2:  # ÌòÑÏû¨Í∞Ä 20% Î≤îÏúÑ ÎÇ¥
                    line_data = [level] * len(df)
                    additional_plots.append(
                        mpf.make_addplot(line_data, color='green', 
                                       width=1, linestyle='--', alpha=0.7)
                    )
            
            for level in support_resistance.resistance_levels:
                if abs(level - current_price) / current_price < 0.2:
                    line_data = [level] * len(df)
                    additional_plots.append(
                        mpf.make_addplot(line_data, color='red', 
                                       width=1, linestyle='--', alpha=0.7)
                    )
            
            # Ï∞®Ìä∏ Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
            mc = mpf.make_marketcolors(
                up='red', down='blue',
                edge='inherit',
                wick={'up': 'red', 'down': 'blue'},
                volume='in'
            )
            
            s = mpf.make_mpf_style(
                marketcolors=mc,
                gridstyle='-',
                y_on_right=True
            )
            
            # Î©îÎ™®Î¶¨ ÎÇ¥ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
            buf = io.BytesIO()
            
            # Ï∞®Ìä∏ ÏÉùÏÑ±
            mpf.plot(
                df,
                type='candle',
                style=s,
                volume=True,
                addplot=additional_plots if additional_plots else None,
                figsize=(12, 8),
                title=f'{stock_code} Ï£ºÍ∞Ä Ï∞®Ìä∏ ({period})',
                ylabel='Í∞ÄÍ≤© (Ïõê)',
                ylabel_lower='Í±∞ÎûòÎüâ',
                savefig=dict(fname=buf, format='png', dpi=100, bbox_inches='tight'),
                returnfig=False
            )
            
            # base64 Ïù∏ÏΩîÎî©
            buf.seek(0)
            image_base64 = base64.b64encode(buf.read()).decode('utf-8')
            buf.close()
            
            logger.info(f"üìä {stock_code} Ï∞®Ìä∏ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± ÏôÑÎ£å")
            return image_base64
            
        except Exception as e:
            logger.error(f"‚ùå Ï∞®Ìä∏ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            # Ïò§Î•ò Ïãú Í∞ÑÎã®Ìïú Ï∞®Ìä∏ ÏÉùÏÑ±
            return self._generate_simple_chart(stock_code, period)
    
    def _generate_simple_chart(self, stock_code: str, period: str) -> str:
        """Í∞ÑÎã®Ìïú Ï∞®Ìä∏ ÏÉùÏÑ± (Ïò§Î•ò Ïãú Î∞±ÏóÖ)"""
        try:
            df = self.get_stock_data(stock_code, period)
            
            plt.figure(figsize=(10, 6))
            plt.plot(df.index, df['Close'], linewidth=1.5, color='blue')
            plt.title(f'{stock_code} Ï£ºÍ∞Ä Ï∞®Ìä∏ ({period})', fontsize=14)
            plt.xlabel('ÎÇ†Ïßú')
            plt.ylabel('Ï£ºÍ∞Ä (Ïõê)')
            plt.xticks(rotation=45)
            plt.grid(True, alpha=0.3)
            plt.tight_layout()
            
            # base64 Ïù∏ÏΩîÎî©
            buf = io.BytesIO()
            plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
            buf.seek(0)
            image_base64 = base64.b64encode(buf.read()).decode('utf-8')
            buf.close()
            plt.close()
            
            return image_base64
            
        except Exception as e:
            logger.error(f"‚ùå Í∞ÑÎã®Ìïú Ï∞®Ìä∏ ÏÉùÏÑ±ÎèÑ Ïã§Ìå®: {e}")
            return ""
    
    def get_chart_analysis_summary(self, stock_code: str, period: str = '1M') -> Dict[str, Any]:
        """üìä Ï∞®Ìä∏ Î∂ÑÏÑù Ï¢ÖÌï© ÏöîÏïΩ"""
        try:
            # Î™®Îì† Î∂ÑÏÑù Ïã§Ìñâ
            indicators = self.calculate_technical_indicators(stock_code, period)
            patterns = self.detect_patterns(stock_code, period)
            support_resistance = self.get_support_resistance(stock_code, period)
            df = self.get_stock_data(stock_code, period)
            
            if len(df) == 0:
                return {}
            
            current_price = df['Close'].iloc[-1]
            
            # Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ïã†Ìò∏ Ï¢ÖÌï©
            signals = []
            
            # Ïù¥ÎèôÌèâÍ∑†ÏÑ† Ïã†Ìò∏
            if indicators.sma_5 is not None and indicators.sma_20 is not None:
                sma5_current = indicators.sma_5[-1]
                sma20_current = indicators.sma_20[-1]
                
                if not np.isnan(sma5_current) and not np.isnan(sma20_current):
                    if sma5_current > sma20_current:
                        signals.append("Îã®Í∏∞ ÏÉÅÏäπ Ïã†Ìò∏ (SMA5 > SMA20)")
                    else:
                        signals.append("Îã®Í∏∞ ÌïòÎùΩ Ïã†Ìò∏ (SMA5 < SMA20)")
            
            # RSI Ïã†Ìò∏
            if indicators.rsi is not None:
                rsi_current = indicators.rsi[-1]
                if not np.isnan(rsi_current):
                    if rsi_current > 70:
                        signals.append("Í≥ºÎß§Ïàò Íµ¨Í∞Ñ (RSI > 70)")
                    elif rsi_current < 30:
                        signals.append("Í≥ºÎß§ÎèÑ Íµ¨Í∞Ñ (RSI < 30)")
            
            # Ìå®ÌÑ¥ Ïã†Ìò∏
            for pattern in patterns:
                signals.append(f"{pattern.pattern_type} Ìå®ÌÑ¥ Í∞êÏßÄ (Ïã†Î¢∞ÎèÑ: {pattern.confidence:.1%})")
            
            # Ï¢ÖÌï© Î∂ÑÏÑù Í≤∞Í≥º
            summary = {
                'stock_code': stock_code,
                'current_price': current_price,
                'period': period,
                'analysis_time': datetime.now().isoformat(),
                'trend': support_resistance.current_trend,
                'support_levels': support_resistance.support_levels,
                'resistance_levels': support_resistance.resistance_levels,
                'detected_patterns': [p.pattern_type for p in patterns],
                'technical_signals': signals,
                'data_points': len(df)
            }
            
            # RSI, MACD ÌòÑÏû¨ Í∞í Ï∂îÍ∞Ä
            if indicators.rsi is not None and not np.isnan(indicators.rsi[-1]):
                summary['rsi'] = round(indicators.rsi[-1], 2)
            
            if indicators.macd is not None and not np.isnan(indicators.macd[-1]):
                summary['macd'] = round(indicators.macd[-1], 2)
            
            logger.info(f"üìä {stock_code} Ï∞®Ìä∏ Î∂ÑÏÑù ÏöîÏïΩ ÏôÑÎ£å")
            return summary
            
        except Exception as e:
            logger.error(f"‚ùå Ï∞®Ìä∏ Î∂ÑÏÑù ÏöîÏïΩ Ïã§Ìå®: {e}")
            return {}
    
    def cleanup(self):
        """Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨"""
        try:
            # matplotlib Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨
            plt.close('all')
            logger.info("üßπ ChartManager Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨ ÏôÑÎ£å")
        except Exception as e:
            logger.error(f"‚ùå Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨ Ïã§Ìå®: {e}")

    # ===================================================================
    # chart_generator.pyÏóêÏÑú Í∞ÄÏ†∏Ïò® Ï∞®Ìä∏ ÏÉùÏÑ± Í∏∞Îä•Îì§
    # ===================================================================
    
    def create_comprehensive_chart(self, symbol: str, period_days: int = 30, save_path: str = None) -> str:
        """üî• Ï¢ÖÌï© Ï£ºÏãù Ï∞®Ìä∏ ÏÉùÏÑ± (Ï∫îÎì§Ïä§Ìã± + Í±∞ÎûòÎüâ + ÏßÄÌëú)"""
        try:
            logger.info(f"üìä {symbol} Ï¢ÖÌï© Ï∞®Ìä∏ ÏÉùÏÑ± ÏãúÏûë (Í∏∞Í∞Ñ: {period_days}Ïùº)")
            
            # 1. Îç∞Ïù¥ÌÑ∞ ÏàòÏßë (Í∏∞Ï°¥ get_stock_data ÌôúÏö©)
            chart_data = self.get_stock_data(symbol, period=f'{int(period_days/30)}M' if period_days >= 30 else f'{int(period_days/7)}W')

            if chart_data.empty:
                logger.error(f"‚ùå {symbol} Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®")
                return None
            
            # 2. Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ (Í∏∞Ï°¥ Î©îÏÑúÎìú Ïû¨ÌôúÏö©)
            indicators = self.calculate_technical_indicators(df=chart_data)
            chart_data['sma_5'] = indicators.sma_5
            chart_data['sma_20'] = indicators.sma_20
            chart_data['sma_60'] = indicators.sma_60
            chart_data['rsi'] = indicators.rsi
            
            # 3. Ï∞®Ìä∏ Í∑∏Î¶¨Í∏∞
            fig = plt.figure(figsize=(16, 12))
            
            # Î†àÏù¥ÏïÑÏõÉ: Ï£ºÍ∞ÄÏ∞®Ìä∏(70%) + Í±∞ÎûòÎüâ(30%)
            gs = fig.add_gridspec(3, 1, height_ratios=[2.5, 1, 0.5], hspace=0.1)
            
            # Î©îÏù∏ Ï∞®Ìä∏ (Ï∫îÎì§Ïä§Ìã± + Ïù¥ÎèôÌèâÍ∑†)
            ax1 = fig.add_subplot(gs[0])
            self._draw_candlestick_chart(ax1, chart_data, symbol)
            
            # Í±∞ÎûòÎüâ Ï∞®Ìä∏
            ax2 = fig.add_subplot(gs[1], sharex=ax1)
            self._draw_volume_chart(ax2, chart_data)
            
            # Í∏∞Ïà†Ï†Å ÏßÄÌëú (RSI)
            ax3 = fig.add_subplot(gs[2], sharex=ax1)
            self._draw_rsi_chart(ax3, chart_data)
            
            # Ï∞®Ìä∏ Ïä§ÌÉÄÏùºÎßÅ
            self._style_chart(fig, ax1, ax2, ax3, symbol)
            
            # Ï∞®Ìä∏ Ï†ÄÏû•
            if not save_path:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                save_path = os.path.join(self.chart_dir, f"{symbol}_chart_{timestamp}.png")
            
            plt.savefig(save_path, dpi=150, bbox_inches='tight', 
                       facecolor='white', edgecolor='none')
            plt.close()
            
            logger.info(f"‚úÖ Ï∞®Ìä∏ Ï†ÄÏû• ÏôÑÎ£å: {save_path}")
            return save_path
            
        except Exception as e:
            logger.error(f"‚ùå Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            import traceback
            traceback.print_exc()
            return None

    def create_market_heatmap(self, symbols: List[str], save_path: str = None) -> str:
        """üå°Ô∏è ÏãúÏû• ÌûàÌä∏Îßµ ÏÉùÏÑ± (Ïó¨Îü¨ Ï¢ÖÎ™© ÏÉÅÏäπÎ•† ÎπÑÍµê)"""
        try:
            logger.info(f"üå°Ô∏è ÏãúÏû• ÌûàÌä∏Îßµ ÏÉùÏÑ±: {len(symbols)}Í∞ú Ï¢ÖÎ™©")
            
            market_data = []
            for symbol in symbols:
                try:
                    if self.trader:
                        # CoreTraderÎ•º ÌÜµÌï¥ ÌòÑÏû¨Í∞Ä Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
                        price_info = self.trader.get_current_price(symbol)
                        if price_info:
                            market_data.append({
                                'symbol': symbol,
                                'name': price_info.get('name', symbol),
                                'change_pct': float(price_info.get('prdy_ctrt', 0.0)) # Ï†ÑÏùº ÎåÄÎπÑ Îì±ÎùΩÎ•†
                            })
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {symbol} ÌûàÌä∏Îßµ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®: {e}")
                    continue
            
            if len(market_data) < 1:
                logger.warning("ÌûàÌä∏Îßµ ÏÉùÏÑ±ÏùÑ ÏúÑÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.")
                return None
            
            df = pd.DataFrame(market_data)
            df = df.sort_values('change_pct', ascending=False)
            
            fig, ax = plt.subplots(figsize=(12, max(8, len(df) * 0.5)))
            colors = ['#27AE60' if x >= 0 else '#E74C3C' for x in df['change_pct']]
            bars = ax.barh(df['name'], df['change_pct'], color=colors, alpha=0.8)
            
            ax.set_xlabel('Îì±ÎùΩÎ•† (%)', fontsize=12)
            ax.set_title('üìä Ïã§ÏãúÍ∞Ñ ÏãúÏû• Îì±ÎùΩÎ•† ÌûàÌä∏Îßµ', fontsize=16, fontweight='bold', pad=20)
            ax.grid(True, axis='x', linestyle='--', alpha=0.5)
            ax.axvline(x=0, color='black', linewidth=1.2)

            for bar in bars:
                width = bar.get_width()
                label_x_pos = width + 0.1 if width >= 0 else width - 0.1
                ax.text(label_x_pos, bar.get_y() + bar.get_height()/2, f'{width:.1f}%', 
                        va='center', ha='left' if width >= 0 else 'right')

            plt.tight_layout()
            
            if not save_path:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                save_path = os.path.join(self.chart_dir, f"market_heatmap_{timestamp}.png")
            
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            plt.close()
            
            logger.info(f"‚úÖ ÌûàÌä∏Îßµ Ï†ÄÏû•: {save_path}")
            return save_path
            
        except Exception as e:
            logger.error(f"‚ùå ÌûàÌä∏Îßµ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return None

    def _draw_candlestick_chart(self, ax, df: pd.DataFrame, symbol: str):
        """Ï∫îÎì§Ïä§Ìã± Î∞è Ïù¥ÎèôÌèâÍ∑†ÏÑ† Í∑∏Î¶¨Í∏∞"""
        for i, row in df.iterrows():
            color = '#27AE60' if row['Close'] >= row['Open'] else '#E74C3C'
            ax.add_patch(Rectangle((mdates.date2num(i), row['Open']), 0.8, row['Close']-row['Open'], 
                                   facecolor=color, edgecolor=color, zorder=3))
            ax.plot([mdates.date2num(i)+0.4, mdates.date2num(i)+0.4], [row['Low'], row['High']], 
                    color=color, zorder=2)

        # Ïù¥ÎèôÌèâÍ∑†ÏÑ†
        ax.plot(df.index, df['sma_5'], label='5ÏùºÏÑ†', color='#FFA500', linestyle='--', linewidth=1.5)
        ax.plot(df.index, df['sma_20'], label='20ÏùºÏÑ†', color='#2E86AB', linewidth=1.5)
        ax.plot(df.index, df['sma_60'], label='60ÏùºÏÑ†', color='#8E44AD', linewidth=1.5)
        
        ax.legend()
        ax.set_ylabel('Ï£ºÍ∞Ä (Ïõê)')
        ax.set_title(f'{symbol} Ï¢ÖÌï© Ï∞®Ìä∏', fontsize=16, fontweight='bold')
        ax.grid(True, linestyle='--', alpha=0.5)

    def _draw_volume_chart(self, ax, df: pd.DataFrame):
        """Í±∞ÎûòÎüâ Ï∞®Ìä∏ Í∑∏Î¶¨Í∏∞"""
        colors = ['#27AE60' if c >= o else '#E74C3C' for o, c in zip(df['Open'], df['Close'])]
        ax.bar(df.index, df['Volume'], color=colors, alpha=0.7, width=0.8)
        ax.set_ylabel('Í±∞ÎûòÎüâ')
        ax.grid(True, linestyle='--', alpha=0.5)

    def _draw_rsi_chart(self, ax, df: pd.DataFrame):
        """RSI Ï∞®Ìä∏ Í∑∏Î¶¨Í∏∞"""
        ax.plot(df.index, df['rsi'], label='RSI', color='#C0392B')
        ax.axhline(70, color='red', linestyle=':', linewidth=1, label='Í≥ºÎß§Ïàò(70)')
        ax.axhline(30, color='blue', linestyle=':', linewidth=1, label='Í≥ºÎß§ÎèÑ(30)')
        ax.set_ylim(0, 100)
        ax.set_ylabel('RSI')
        ax.legend(fontsize='small')
        ax.grid(True, linestyle='--', alpha=0.5)
        
        # ÎÇ†Ïßú Ìè¨Îß∑ ÏÑ§Ï†ï
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%m-%d'))
        plt.setp(ax.get_xticklabels(), rotation=30, ha='right')

    def _style_chart(self, fig, ax1, ax2, ax3, symbol: str):
        """Ï∞®Ìä∏ Ï†ÑÎ∞ò Ïä§ÌÉÄÏùºÎßÅ"""
        fig.suptitle(f'Ï¢ÖÌï© Í∏∞Ïà†Ï†Å Î∂ÑÏÑù: {symbol}', fontsize=20, fontweight='bold', y=0.98)
        plt.setp(ax1.get_xticklabels(), visible=False)
        plt.set_p(ax2.get_xticklabels(), visible=False)
        
        # ÏõåÌÑ∞ÎßàÌÅ¨
        fig.text(0.5, 0.5, 'AI Trader Analysis', fontsize=40, color='gray', 
                 ha='center', va='center', alpha=0.1, rotation=30) 