```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ğŸ§  ì‹¤ì‹œê°„ ML/DL ì—”ì§„ v2.0 (ìµœì í™” ë²„ì „)
=====================================

ì‹¤ì „ë§¤ë§¤ ì ìš© ê°€ëŠ¥í•œ ë¨¸ì‹ ëŸ¬ë‹/ë”¥ëŸ¬ë‹ í†µí•© ì‹œìŠ¤í…œ
- ë¨¸ì‹ ëŸ¬ë‹ 70% + ë”¥ëŸ¬ë‹ 30% ì•™ìƒë¸” êµ¬ì¡°
- Gemini AI ë‰´ìŠ¤/ê³µì‹œ ê°ì •ë¶„ì„ í†µí•©
- 24ì‹œê°„ ì‹¤ì‹œê°„ í•™ìŠµ ë° ì˜ˆì¸¡
- í…”ë ˆê·¸ë¨ ì‹¤ì‹œê°„ ì•Œë¦¼ ì‹œìŠ¤í…œ
- GPU ê°€ì† ë”¥ëŸ¬ë‹ ëª¨ë¸
- ë°±í…ŒìŠ¤íŠ¸ ë° ì„±ëŠ¥ í‰ê°€ ìë™í™”

ìµœì í™” ëŒ€ìƒ PC ì‚¬ì–‘:
  â€¢ CPU: Intel i9-14900KF (24ì½”ì–´, 32ìŠ¤ë ˆë“œ)
  â€¢ GPU: NVIDIA RTX 5080 (ëŒ€ìš©ëŸ‰ VRAM)
  â€¢ RAM: DDR5 32GB
  â€¢ ì €ì¥ê³µê°„: NVMe SSD 1TB

ìµœì í™” ì „ëµ:
  â€¢ ë©€í‹°ìŠ¤ë ˆë“œ/ë©€í‹°í”„ë¡œì„¸ì‹± ìµœëŒ€ í™œìš© (n_jobs=-1)
  â€¢ ëŒ€ìš©ëŸ‰ ë°ì´í„° ìºì‹± ë° ë©”ëª¨ë¦¬ íš¨ìœ¨í™”
  â€¢ GPU í™œìš©(PyTorch/TensorFlow GPU ê°€ì†)
  â€¢ ëŒ€ê·œëª¨ ì•™ìƒë¸”/ë”¥ëŸ¬ë‹ í™•ì¥ì„± ê³ ë ¤
  â€¢ ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì§‘ ë° ë¹ ë¥¸ I/O
  â€¢ ë³‘ë ¬ ì°¨íŠ¸ ìƒì„±, ëŒ€ìš©ëŸ‰ ì´ë¯¸ì§€ ì²˜ë¦¬
  â€¢ ê³ ì„±ëŠ¥ íŒŒë¼ë¯¸í„°(íŠ¸ë¦¬ ê°œìˆ˜, ë”¥ëŸ¬ë‹ í™•ì¥ ë“±)
  â€¢ ë©”ëª¨ë¦¬/CPU/GPU ì‚¬ìš©ëŸ‰ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
  â€¢ ìë™ ì¬í•™ìŠµ ë° ì„±ëŠ¥ ê°œì„  ì•Œë¦¼
"""

from dotenv import load_dotenv
load_dotenv()  # .env íŒŒì¼ ìë™ ë¡œë“œ

import os
import json
import pickle
import logging
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple, Union
from dataclasses import dataclass
from pathlib import Path
import warnings
warnings.filterwarnings('ignore')

# ML ë¼ì´ë¸ŒëŸ¬ë¦¬
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.pipeline import Pipeline

# API ê´€ë ¨
import requests
from PIL import Image
import io
import base64

# í…”ë ˆê·¸ë¨ ì•Œë¦¼ í•¨ìˆ˜ ì¶”ê°€
import requests as _requests

import time
import traceback
import psutil

# ... (ì¤‘ëµ) ...

# ... (ê¸°ì¡´ ì½”ë“œ) ...

# ... (ì—¬ê¸°ê¹Œì§€ ê¸°ì¡´ ì½”ë“œ) ...

# (1705ë²ˆì§¸ ì¤„ ê·¼ì²˜ì—ì„œ ìˆ˜ì •ëœ ë¶€ë¶„) (ê°€ì •)

# ... (ê¸°ì¡´ ì½”ë“œ) ...


    def _calculate_performance_metrics(self, y_true: Union[np.ndarray, pd.Series], y_pred: Union[np.ndarray, pd.Series]) -> Dict[str, float]:
        """ì„±ëŠ¥ ì§€í‘œ ê³„ì‚°"""
        try:
            # numpy ë°°ì—´ë¡œ ë³€í™˜
            y_true_arr = np.array(y_true, dtype=float)
            y_pred_arr = np.array(y_pred, dtype=float)
            
            mse = mean_squared_error(y_true_arr, y_pred_arr)
            r2 = r2_score(y_true_arr, y_pred_arr)
            mae = mean_absolute_error(y_true_arr, y_pred_arr)
            
            # ì •í™•ë„ ê³„ì‚° (ë°©í–¥ì„± ì˜ˆì¸¡)
            direction_true = np.sign(y_true_arr)
            direction_pred = np.sign(y_pred_arr)
            accuracy = np.mean(direction_true == direction_pred) * 100
            
            # ìˆ˜ìµë¥  ê³„ì‚° (ê°€ìƒ)
            profit_rate = accuracy * 0.3  # ì •í™•ë„ ê¸°ë°˜ ìˆ˜ìµë¥  ì¶”ì •
            
            return {
                'mse': float(mse),
                'r2': float(r2),
                'mae': float(mae),
                'accuracy': float(accuracy),
                'profit_rate': float(profit_rate)
            }
        except Exception as e:
            logger.error(f"ì„±ëŠ¥ ì§€í‘œ ê³„ì‚° ì‹¤íŒ¨: {e}")
            return {'mse': 0.0, 'r2': 0.0, 'mae': 0.0, 'accuracy': 0.0, 'profit_rate': 0.0}
        
# ... (ë‚˜ë¨¸ì§€ ì½”ë“œ) ...
```